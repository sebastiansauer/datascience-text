{
  "hash": "704f6c4d9f86bab76fb92bb51a813fdb",
  "result": {
    "markdown": "\n# Textmining1\n\n\n\n![Text als Datenbasis prädiktiver Modelle](img/text-mining-1476780_640.png){width=10%}\nBild von <a href=\"https://pixabay.com/de/users/mcmurryjulie-2375405/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1476780\">mcmurryjulie</a> auf <a href=\"https://pixabay.com/de//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1476780\">Pixabay</a>\n\n\n\n## Vorab\n\n\n### Lernziele\n\n\n- Die vorgestellten Techniken des Textminings mit R anwenden können\n\n\n\n### Vorbereitung\n\n- Lesen Sie in @smltar Kap. 2.\n\n\n\n### Benötigte R-Pakete\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-1_9a5335aa4b1eaf46d0f2f34bb7740833'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tokenizers)\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(hcandersenr)\nlibrary(SnowballC)  # Stemming\nlibrary(lsa)  # Stopwörter\nlibrary(easystats)  # Komfort für deskriptive Statistiken, wie `describe_distribution`\n```\n:::\n\n\n\n\n## Einfache Methoden des Textminings\n\n\nArbeiten Sie die folgenden grundlegenden Methoden des Textminigs durch.\n\n\n\n\n### Tokenisierung\n\nErarbeiten Sie dieses Kapitel: @smltar, [Kap. 2](https://smltar.com/tokenization.html#tokenization)\n\nWie viele Zeilen hat das Märchen \"The Fir tree\" (in der englischen Fassung?)\n\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-2_2e0097677e2d8b431aba9da157179c5f'}\n\n```{.r .cell-code}\nhcandersen_en %>% \n  filter(book == \"The fir tree\") %>% \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 253\n```\n:::\n:::\n\n\n\n### Stopwörter entfernen\n\n\nErarbeiten Sie dieses Kapitel: s. @smltar, [Kap. 3](https://smltar.com/stopwords.html#stopwords)\n\n\n\nEine alternative Quelle von Stopwörtern - in verschiedenen Sprachen - \nbiwetet das Paket `quanteda`:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-3_9c675601d713b56beb49b87b33140d10'}\n\n```{.r .cell-code}\nstop2 <-\n  tibble(word = quanteda::stopwords(\"german\"))\n\nhead(stop2)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|word  |\n|:-----|\n|aber  |\n|alle  |\n|allem |\n|allen |\n|aller |\n|alles |\n\n</div>\n:::\n:::\n\n\nEs bestehst (in der deutschen Version) aus 231 Wörtern.\n\n\n\n\n### Wörter zählen {#sec-woerterzaehlen}\n\nIst der Text tokenisiert, kann man einfach mit \"Bordmitteln\" die Wörter zählen.\n\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-4_420b7dc93f1e442209602a7e4db4348b'}\n\n```{.r .cell-code}\nhcandersen_de %>% \n  filter(book == \"Das Feuerzeug\") %>% \n  unnest_tokens(output = word, input = text) %>% \n  anti_join(stop2) %>% \n  count(word, sort = TRUE) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"word\"\n```\n:::\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|word       |  n|\n|:----------|--:|\n|soldat     | 35|\n|sagte      | 28|\n|hund       | 23|\n|prinzessin | 17|\n|hexe       | 16|\n|feuerzeug  | 14|\n\n</div>\n:::\n:::\n\n\n\n\n\n### Stemming (Wortstamm finden)\n\nErarbeiten Sie dieses Kapitel: @smltar, [Kap. 4](https://smltar.com/stemming.html#stemming)\n\n\nVertiefende Hinweise zum UpSet plot finden Sie [hier](https://ieeexplore.ieee.org/document/6876017), @lex_upset_2014.\n\n\nFür welche Sprachen gibt es Stemming im Paket `SnowballC`?\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-5_c1a65ebfb517c53003faa3b11a1cf801'}\n\n```{.r .cell-code}\nlibrary(SnowballC)\ngetStemLanguages()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"arabic\"     \"basque\"     \"catalan\"    \"danish\"     \"dutch\"     \n [6] \"english\"    \"finnish\"    \"french\"     \"german\"     \"greek\"     \n[11] \"hindi\"      \"hungarian\"  \"indonesian\" \"irish\"      \"italian\"   \n[16] \"lithuanian\" \"nepali\"     \"norwegian\"  \"porter\"     \"portuguese\"\n[21] \"romanian\"   \"russian\"    \"spanish\"    \"swedish\"    \"tamil\"     \n[26] \"turkish\"   \n```\n:::\n:::\n\n\n\nEinfacher Test: Suchen wir den Wordstamm für das Wort \"wissensdurstigen\", wie in \"die wissensdurstigen Studentis löcherten dis armi Professi\"^[[Gender-i](https://gender-i.de/#mit-bestimmtem-artikel)].\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-6_dc5783d3c9f3bc9d557ba00e0ebad168'}\n\n```{.r .cell-code}\nwordStem(\"wissensdurstigen\", language = \"german\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wissensdurst\"\n```\n:::\n:::\n\n\n\nWerfen Sie mal einen Blick in das Handbuch von [SnowballC](https://cran.r-project.org/web/packages/SnowballC/SnowballC.pdf).\n\n\n\n### Fallstudie AfD-Parteiprogramm\n\n\n\nDaten einlesen:\n\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-7_1f4740dcfc79e1aa551240f1e2a6211f'}\n\n```{.r .cell-code}\nd_link <- \"https://raw.githubusercontent.com/sebastiansauer/pradadata/master/data-raw/afd_2022.csv\"\nafd <- read_csv(d_link, show_col_types = FALSE)\n```\n:::\n\n\nWie viele Seiten hat das Dokument?\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-8_87826efe7c441852270a057af8766720'}\n\n```{.r .cell-code}\nnrow(afd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 190\n```\n:::\n:::\n\n\nUnd wie viele Wörter?\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-9_04a3d2a2d0d640a1cbdbefcad3cc70dc'}\n\n```{.r .cell-code}\nstr_count(afd$text, pattern = \"\\\\w\") %>% sum(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 179375\n```\n:::\n:::\n\n\n\n\nAus breit mach lang, oder: wir tokenisieren (nach Wörtern): \n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-10_a0bf20fc807ddc3e52351cb24add2ce3'}\n\n```{.r .cell-code}\nafd %>% \n  unnest_tokens(output = token, input = text) %>% \n  filter(str_detect(token, \"[a-z]\")) -> afd_long\n```\n:::\n\n\n\nStopwörter entfernen:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-11_1a2f426f18fda46468d2881d40a2cdb4'}\n\n```{.r .cell-code}\ndata(stopwords_de, package = \"lsa\")\n\nstopwords_de <- tibble(word = stopwords_de)\n\n# Für das Joinen werden gleiche Spaltennamen benötigt:\nstopwords_de <- stopwords_de %>% \n  rename(token = word)  \n\nafd_long %>% \n  anti_join(stopwords_de) -> afd_no_stop\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"token\"\n```\n:::\n:::\n\n\n\nWörter zählen:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-12_b3e1b3d7c343e763cc1c9dfcbec5a0d2'}\n\n```{.r .cell-code}\nafd_no_stop %>% \n  count(token, sort = TRUE) -> afd_count\n\nhead(afd_count)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|token       |   n|\n|:-----------|---:|\n|afd         | 174|\n|deutschland | 113|\n|wollen      |  66|\n|euro        |  60|\n|bürger      |  57|\n|eu          |  54|\n\n</div>\n:::\n:::\n\n\n\nWörter trunkieren:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-13_f45d847b3e66ed4b9fc65f8246e09a9f'}\n\n```{.r .cell-code}\nafd_no_stop %>% \n  mutate(token_stem = wordStem(token, language = \"de\")) %>% \n  count(token_stem, sort = TRUE) -> afd_count_stemmed\n\nhead(afd_no_stop)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| page|token              |\n|----:|:------------------|\n|    1|programm           |\n|    1|deutschland        |\n|    1|grundsatzprogramm  |\n|    1|alternative        |\n|    1|deutschland        |\n|    2|inhaltsverzeichnis |\n\n</div>\n:::\n:::\n\n\n\n\n### Stringverarbeitung\n\n\n\nErarbeiten Sie dieses Kapitel: @r4ds, [Kap. 14](https://r4ds.had.co.nz/strings.html)\n\n\n\n#### Regulärausdrücke {#regex}\n\nDas `\"[a-z]\"` in der Syntax oben steht für \"alle Buchstaben von a-z\". D\niese flexible Art von \"String-Verarbeitung mit Jokern\" nennt man *Regulärausdrücke* (regular expressions; regex). \nEs gibt eine ganze Reihe von diesen Regulärausdrücken, die die Verarbeitung von Texten erleichert. \nMit dem Paket `stringr` geht das - mit etwas Übung - gut von der Hand. \nNehmen wir als Beispiel den Text eines Tweets:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-14_dbba7363cab79afe240df8158b78556d'}\n\n```{.r .cell-code}\nstring <- \"Correlation of unemployment and #AfD votes at #btw17: ***r = 0.18***\\n\\nhttps://t.co/YHyqTguVWx\"  \n```\n:::\n\n\nMöchte man Ziffern identifizieren, so hilft der Reulärausdruck `[:digit:]`:\n\n\"Gibt es mindestens eine Ziffer in dem String?\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-15_aeaf8aacc91fd2df9a3ac435eddd6810'}\n\n```{.r .cell-code}\nstr_detect(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\"Finde die Position der ersten Ziffer! Welche Ziffer ist es?\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-16_a2217b2303a948a0c7baf89568567ebf'}\n\n```{.r .cell-code}\nstr_locate(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     start end\n[1,]    51  51\n```\n:::\n\n```{.r .cell-code}\nstr_extract(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"\n```\n:::\n:::\n\n\n\"Finde alle Ziffern!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-17_710c01105055e42e63d13b6de50a99c1'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"1\" \"7\" \"0\" \"1\" \"8\"\n```\n:::\n:::\n\n\n\n\"Finde alle Stellen an denen genau 2 Ziffern hintereinander folgen!\"\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-18_2457cf00cd118564ab7e8e5b6453fd2b'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"[:digit:]{2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"17\" \"18\"\n```\n:::\n:::\n\n\nDer Quantitätsoperator `{n}` findet alle Stellen, in der der der gesuchte Ausdruck genau $n$ mal auftaucht.\n\n\n\"Zeig die Hashtags!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-19_a38b594b6abcacdf5dac6402e6e6c7a5'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"#[:alnum:]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"#AfD\"   \"#btw17\"\n```\n:::\n:::\n\n\nDer Operator `[:alnum:]` steht für \"alphanumerischer Charakter\" - also eine Ziffer oder ein Buchstabe; synonym hätte man auch `\\\\w` schreiben können (w wie word). Warum werden zwei Backslashes gebraucht? Mit `\\\\w` wird signalisiert, dass nicht der Buchstabe *w*, sondern etwas Besonderes, eben der Regex-Operator `\\w` gesucht wird. \n\n\"Zeig die URLs!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-20_f5cafffeb49c286a6cbe5f41dd83fa69'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"https?://[:graph:]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"https://t.co/YHyqTguVWx\"\n```\n:::\n:::\n\n\nDas Fragezeichen `?` ist eine Quantitätsoperator, der einen Treffer liefert, wenn das vorherige Zeichen (hier *s*) null oder einmal gefunden wird. `[:graph:]` ist die Summe von `[:alpha:]` (Buchstaben, groß und klein), `[:digit:]` (Ziffern) und `[:punct:]` (Satzzeichen u.ä.).\n\n\"Zähle die Wörter im String!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-21_cdcaebb13d7ebf5a13293c87f9b20bbd'}\n\n```{.r .cell-code}\nstr_count(string, boundary(\"word\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n:::\n\n\n\n\"Liefere nur Buchstaben*folgen* zurück, lösche alles übrige\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-22_2c2e1ea1cc900b579836bd516aa271b7'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"[:alpha:]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Correlation\"  \"of\"           \"unemployment\" \"and\"          \"AfD\"         \n [6] \"votes\"        \"at\"           \"btw\"          \"r\"            \"https\"       \n[11] \"t\"            \"co\"           \"YHyqTguVWx\"  \n```\n:::\n:::\n\n\nDer Quantitätsoperator `+` liefert alle Stellen zurück, in denen der gesuchte Ausdruck *einmal oder häufiger*  vorkommt. Die Ergebnisse werden als Vektor von Wörtern zurückgegeben. Ein anderer Quantitätsoperator ist `*`, der für 0 oder mehr Treffer steht. Möchte man einen Vektor, der aus Stringen-Elementen besteht zu einem Strring zusammenfüngen, hilft `paste(string)` oder `str_c(string, collapse = \" \")`.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-23_f0b099c5d6d9d081aaa05a90c589b314'}\n\n```{.r .cell-code}\nstr_replace_all(string, \"[^[:alpha:]+]\", \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CorrelationofunemploymentandAfDvotesatbtwrhttpstcoYHyqTguVWx\"\n```\n:::\n:::\n\n\nMit dem Negationsoperator `[^x]` wird der Regulärausrck `x` negiert; die Syntax oben heißt also \"ersetze in `string` alles außer Buchstaben durch Nichts\". Mit \"Nichts\" sind hier Strings der Länge Null gemeint; ersetzt man einen belieibgen String durch einen String der Länge Null, so hat man den String gelöscht.\n\nDas Cheatsheet zur Strings bzw zu `stringr` von RStudio gibt einen guten Überblick über Regex; im Internet finden sich viele Beispiele.\n\n\n\n## Regex im Texteditor\n\n\nEinige Texteditoren unterstützen Regex, so auch RStudio.\n\nDas ist eine praktische Sache. \nEin Beispiel: Sie haben eine Liste mit Namen der Art:\n\n- Nachname1, Vorname1\n- Nachname2, Vorname2\n- Nachname3, Vorname3\n\n\nUnd Sie möchten jetzt aber die Liste mit Stil *Vorname Nachname* sortiert haben.\n\nRStudio mit Regex macht's möglich, s. @fig-regex-rstudio.\n\n\n::: {#fig-regrex-rstudio}\n\n![Vorher; mit Regex-Syntax](img/regex1.png){#fig-vorher-regex}\n![Vorher; mit Regex-Syntax](img/regex2.png){#fig-nacher-regex}\n\n:::\n\n\n\n### Sentimentanalyse {#sec-sentimentanalyse}\n\n\n#### Einführung\n\n\nEine weitere interessante Analyse ist, die \"Stimmung\" oder \"Emotionen\" (Sentiments) eines Textes auszulesen. \nDie Anführungszeichen deuten an, dass hier ein Maß an Verständnis suggeriert wird, welches nicht (unbedingt) von der Analyse eingehalten wird. \nJedenfalls ist das Prinzip der Sentiment-Analyse im einfachsten Fall so: \n\n\n\n\n\n1. Schau dir jeden Token aus dem Text an.  \n2. Prüfe, ob sich das Wort im Lexikon der Sentiments wiederfindet.  \n3. Wenn ja, dann addiere den Sentimentswert dieses Tokens zum bestehenden Sentiments-Wert.  \n4. Wenn nein, dann gehe weiter zum nächsten Wort.  \n5. Liefere zum Schluss die Summenwerte pro Sentiment zurück.  \n\n\n\n\n     \nEs gibt Sentiment-Lexika, die lediglich einen Punkt für \"positive Konnotation\" bzw. \"negative Konnotation\" geben; andere Lexiko weisen differenzierte Gefühlskonnotationen auf. Wir nutzen hier das Sentimentlexikon `sentiws` [@Remus2010]. Sie können das Lexikon als CSV hier herunterladen:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-24_8ad2e7baefbfeacaa335826a7feef4c9'}\n\n```{.r .cell-code}\nsentiws <- read_csv(\"https://osf.io/x89wq/?action=download\")\n```\n:::\n\n\n\nDen Volltext zum Paper finden Sie z.B. [hier](http://www.lrec-conf.org/proceedings/lrec2010/pdf/490_Paper.pdf).\n\nAlternativ können Sie die Daten aus dem Paket `pradadata` laden. Allerdings müssen Sie dieses Paket von Github installieren:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-25_1a27f7890768945a92e92f9a9cca9fae'}\n\n```{.r .cell-code}\ninstall.packages(\"devtools\", dep = TRUE)\ndevtools::install_github(\"sebastiansauer/pradadata\")\n```\n:::\n\n::: {.cell hash='textmining1_cache/html/parse-sentiment-dics_7b392074be7f9e2faa3b256a45bdc064'}\n\n```{.r .cell-code}\ndata(sentiws, package = \"pradadata\")\n```\n:::\n\n\n@tbl-afdcount zeigt einen Ausschnitt aus dem Sentiment-Lexikon *SentiWS*.\n\n\n::: {#tbl-afdcount .cell tbl-cap='Auszug aus SentiWS' hash='textmining1_cache/html/tbl-afdcount_65282fac3f90acfc5d9eab2b6e2ed3a2'}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|neg_pos |word       |   value|inflections                           |\n|:-------|:----------|-------:|:-------------------------------------|\n|neg     |Abbau      | -0.0580|Abbaus,Abbaues,Abbauen,Abbaue         |\n|neg     |Abbruch    | -0.0048|Abbruches,Abbrüche,Abbruchs,Abbrüchen |\n|neg     |Abdankung  | -0.0048|Abdankungen                           |\n|neg     |Abdämpfung | -0.0048|Abdämpfungen                          |\n|neg     |Abfall     | -0.0048|Abfalles,Abfälle,Abfalls,Abfällen     |\n|neg     |Abfuhr     | -0.3367|Abfuhren                              |\n\n</div>\n:::\n:::\n\n\n\n#### Ungewichtete Sentiment-Analyse\n\nNun können wir jedes Token des Textes mit dem Sentiment-Lexikon abgleichen; \ndabei zählen wir die Treffer für positive bzw. negative Terme. \nZuvor müssen wir aber noch die Daten (`afd_long`) mit dem Sentimentlexikon zusammenführen (joinen). \nDas geht nach bewährter Manier mit `inner_join`; \"inner\" sorgt dabei dafür, dass nur Zeilen behalten werden, die in beiden Dataframes vorkommen. Tabelle @tbl-afdsenti zeigt Summe, Anzahl und Anteil der Emotionswerte.\n\n\nWir nutzen die Tabelle `afd_long`,  die wir oben definiert haben.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-26_0293f7dece3068970384c2f6230d7de2'}\n\n```{.r .cell-code}\nafd_long %>% \n  inner_join(sentiws, by = c(\"token\" = \"word\")) %>% \n  select(-inflections) -> afd_senti  # die Spalte brauchen wir nicht\n\nafd_senti %>% \n  group_by(neg_pos) %>% \n  summarise(polarity_sum = sum(value),\n            polarity_count = n()) %>% \n  mutate(polarity_prop = (polarity_count / sum(polarity_count)) %>% round(2)) ->\n  afd_senti_tab\n```\n:::\n\n::: {#tbl-afdsenti .cell tbl-cap='Zusammenfassung von SentiWS' hash='textmining1_cache/html/tbl-afdsenti_696f0b6db6c35d405ff61879bfb85427'}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|neg_pos | polarity_sum| polarity_count| polarity_prop|\n|:-------|------------:|--------------:|-------------:|\n|neg     |     -48.5307|            210|          0.27|\n|pos     |      30.6595|            578|          0.73|\n\n</div>\n:::\n:::\n\n\n\nDie Analyse zeigt, dass die emotionale Bauart des Textes durchaus interessant ist: \nEs gibt viel mehr positiv getönte Wörter als negativ getönte. \nAllerdings sind die negativen Wörter offenbar deutlich stärker emotional aufgeladen, \ndenn die Summe an Emotionswert der negativen Wörter ist (überraschenderweise?) deutlich größer als die der positiven.\n\nBetrachten wir also die intensivsten negativ und positive konnotierten Wörter näher.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-27_6613f238aea52792eba0132df476e213'}\n\n```{.r .cell-code}\nafd_senti %>% \n  distinct(token, .keep_all = TRUE) %>% \n  mutate(value_abs = abs(value)) %>% \n  top_n(20, value_abs) %>% \n  pull(token)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"ungerecht\"    \"besonders\"    \"gefährlich\"   \"überflüssig\"  \"behindern\"   \n [6] \"gelungen\"     \"brechen\"      \"unzureichend\" \"gemein\"       \"verletzt\"    \n[11] \"zerstören\"    \"trennen\"      \"falsch\"       \"vermeiden\"    \"zerstört\"    \n[16] \"schwach\"      \"belasten\"     \"schädlich\"    \"töten\"        \"verbieten\"   \n```\n:::\n:::\n\n\nDiese \"Hitliste\" wird zumeist (19/20) von negativ polarisierten Begriffen aufgefüllt, \nwobei \"besonders\" ein Intensivierwort ist, welches das Bezugswort verstärt (\"besonders gefährlich\"). \nDas Argument `keep_all = TRUE` sorgt dafür, dass alle Spalten zurückgegeben werden, \nnicht nur die durchsuchte Spalte `token`. \nMit `pull` haben wir aus dem Dataframe, der von den dplyr-Verben übergeben wird, \ndie Spalte `pull` \"herausgezogen\"; \nhier nur um Platz zu sparen bzw. der Übersichtlichkeit halber.\n\n\n     \nNun könnte man noch den erzielten \"Netto-Sentimentswert\" des Corpus ins Verhältnis setzen Sentimentswert des Lexikons:\nWenn es insgesamt im Sentiment-Lexikon sehr negativ zuginge,\nwäre ein negativer Sentimentwer in einem beliebigen Corpus nicht überraschend. `describe_distribution` aus `{easystats}` gibt uns einen Überblick der üblichen deskriptiven Statistiken.\n     \n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-28_d7da1db757a6f38ef261af25853942a6'}\n\n```{.r .cell-code}\nsentiws %>% \n  select(value, neg_pos) %>% \n  #group_by(neg_pos) %>% \n  describe_distribution()\n```\n:::\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-29_da138c62b0f5e7afff42e03cebcaf2b9'}\n::: {.cell-output-display}\n|Variable |  Mean |   SD |  IQR |         Range | Skewness | Kurtosis |    n | n_Missing |\n|:--------|:-----:|:----:|:----:|:-------------:|:--------:|:--------:|:----:|:---------:|\n|value    | -0.05 | 0.20 | 0.05 | (-1.00, 1.00) |    -0.68 |     2.36 | 3468 |         0 |\n:::\n:::\n\n\nInsgesamt ist das Lexikon ziemlich ausgewogen; negative Werte sind leicht in der Überzahl im Lexikon. \nUnser Corpus hat eine ähnliche mittlere emotionale Konnotation wie das Lexikon:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-30_30ffd9129d123c883f5454f1b428e32f'}\n\n```{.r .cell-code}\nafd_senti %>% \n  summarise(senti_sum = mean(value) %>% round(2))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| senti_sum|\n|---------:|\n|     -0.02|\n\n</div>\n:::\n:::\n\n\n\n\n\n\n## Aufgaben\n\n\n- [purrr-map01](https://datenwerk.netlify.app/posts/purrr-map01/purrr-map01.html)\n- [purrr-map02](https://datenwerk.netlify.app/posts/purrr-map02/purrr-map02.html)\n- [purrr-map03](https://datenwerk.netlify.app/posts/purrr-map03/purrr-map03.html)\n- [purrr-map04](https://datenwerk.netlify.app/posts/purrr-map04/purrr-map04.html)\n- [Regex-Übungen](https://regexone.com/)\n- [Aufgaben zum Textmining von Tweets](https://datenwerk.netlify.app/#category=textmining)\n\n\n\n\n## Fallstudie Hate-Speech\n\n\n### Daten\n\nEs finden sich mehrere Datensätze zum Thema Hate-Speech im öffentlichen Internet, eine Quelle ist [Hate Speech Data](https://ckan.hatespeechdata.com/), ein Repositorium, das mehrere Datensätze beinhaltet.\n\n\n\n- [Kaggle Hate Speech and Offensive Language Dataset](https://www.kaggle.com/datasets/mrmorj/hate-speech-and-offensive-language-dataset?select=labeled_data.csv)\n- [Bretschneider and Peters Prejudice on Facebook Dataset](https://ckan.hatespeechdata.com/dataset/bretschneider-and-peters-prejudice-on-facebook-dataset)\n- [Daten zum Fachartikel\"Large Scale Crowdsourcing and Characterization of Twitter Abusive Behavior\"](https://github.com/ENCASEH2020/hatespeech-twitter/blob/master/hatespeech_labels.csv)\n\n\nFür Textmining kann eine Liste mit anstößigen (obszönen) Wörten nützlich sein,\nauch wenn man solche Dinge ungern anfässt, verständlicherweise.\n[Jenyay](https://github.com/Jenyay/Obscene-Words-List) bietet solche Listen in verschiedenen Sprachen an. Die Liste von [KDNOOBW](https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words) sieht sehr ähnlich aus (zumindest die deutsche Version).\nEine lange Sammlung deutscher Schimpfwörter findet sich im [insult.wiki](https://www.insult.wiki/schimpfwort-liste);\nähnlich bei [Hyperhero](http://www.hyperhero.com/de/insults.htm).\n\n\n\n\n\n\n\nTwitterdaten dürfen nur in \"dehydrierter\" Form weitergegeben werden, so dass kein Rückschluss von ID zum Inhalt des Tweets möglich ist. \nDaher werden öffentlich nur die IDs der Tweets, als einzige Information zum Tweet, also ohne den eigentlichen Inhalt des Tweets, bereitgestellt.\n\nÜber die Twitter-API kann man sich, wie oben dargestellt, dann die Tweets wieder \"rehydrieren\", also wieder mit dem zugehörigen Tweet-Text (und sonstigen Infos des Tweets) zu versehen.\n\n\n\n\n### Grundlegendes Text Mining\n\n\nWenden Sie die oben aufgeführten Techniken des grundlegenden Textminings auf einen der oben dargestellten Hate-Speech-Datensätze an.\nErstellen Sie ein (HTML-Dokument) mit Ihren Ergebnissen. \nStellen Sie die Ergebnisse auf dem Github-Repo dieses Kurses ein.\nVergleichen Sie Ihre Lösung mit den Lösungen der anderen Kursmitglieder.\n\nWir nutzen noch nicht eigene Daten, die wir von Twitter ausgelesen haben, das heben wir uns für später auf.\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}