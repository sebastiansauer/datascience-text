{
  "hash": "d9a2209c291a6000ed3c0232771d18a4",
  "result": {
    "markdown": "\n# Textmining1\n\n\n\n![Text als Datenbasis prädiktiver Modelle](img/text-mining-1476780_640.png){width=10%}\nBild von <a href=\"https://pixabay.com/de/users/mcmurryjulie-2375405/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1476780\">mcmurryjulie</a> auf <a href=\"https://pixabay.com/de//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1476780\">Pixabay</a>\n\n\n\n## Vorab\n\n\n### Lernziele\n\n\n- Die vorgestellten Techniken des Textminings mit R anwenden können\n\n\n\n### Vorbereitung\n\n- Lesen Sie in @smltar Kap. 2.\n\n\n\n### Benötigte R-Pakete\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-1_01e6353efc42fb6aa62c5ca4163a8d42'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tokenizers)\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(hcandersenr)\nlibrary(SnowballC)  # Stemming\nlibrary(lsa)  # Stopwörter\nlibrary(easystats)  # Komfort für deskriptive Statistiken, wie `describe_distribution`\nlibrary(textclean)  # Emojis ersetzen\nlibrary(wordcloud)\n```\n:::\n\n\n\n\n## Einfache Methoden des Textminings\n\n\nArbeiten Sie die folgenden grundlegenden Methoden des Textminigs durch.\n\n\n\n\n### Tokenisierung\n\nErarbeiten Sie dieses Kapitel: @smltar, [Kap. 2](https://smltar.com/tokenization.html#tokenization)\n\nWie viele Zeilen hat das Märchen \"The Fir tree\" (in der englischen Fassung?)\n\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-2_2e0097677e2d8b431aba9da157179c5f'}\n\n```{.r .cell-code}\nhcandersen_en %>% \n  filter(book == \"The fir tree\") %>% \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 253\n```\n:::\n:::\n\n\n\n### Stopwörter entfernen\n\n\nErarbeiten Sie dieses Kapitel: s. @smltar, [Kap. 3](https://smltar.com/stopwords.html#stopwords)\n\n\n\nEine alternative Quelle von Stopwörtern - in verschiedenen Sprachen - \nbiwetet das Paket `quanteda`:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-3_9c675601d713b56beb49b87b33140d10'}\n\n```{.r .cell-code}\nstop2 <-\n  tibble(word = quanteda::stopwords(\"german\"))\n\nhead(stop2)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|word  |\n|:-----|\n|aber  |\n|alle  |\n|allem |\n|allen |\n|aller |\n|alles |\n\n</div>\n:::\n:::\n\n\nEs bestehst (in der deutschen Version) aus 231 Wörtern.\n\n\n\n\n### Wörter zählen {#sec-woerterzaehlen}\n\nIst der Text tokenisiert, kann man einfach mit \"Bordmitteln\" die Wörter zählen.\n\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-4_435e970983c14ead9fb624b1a8c7b533'}\n\n```{.r .cell-code}\nhc_andersen_count <- \n  hcandersen_de %>% \n  filter(book == \"Das Feuerzeug\") %>% \n  unnest_tokens(output = word, input = text) %>% \n  anti_join(stop2) %>% \n  count(word, sort = TRUE) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"word\"\n```\n:::\n\n```{.r .cell-code}\nhc_andersen_count %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|word       |  n|\n|:----------|--:|\n|soldat     | 35|\n|sagte      | 28|\n|hund       | 23|\n|prinzessin | 17|\n|hexe       | 16|\n|feuerzeug  | 14|\n\n</div>\n:::\n:::\n\n\n\n\nZur Visualisierung eignen sich Balkendiagramme, s. @fig-hcandersen-count.\n\n\n\n::: {.cell hash='textmining1_cache/html/fig-hc-andersen-count_5eb103ccd6a17e1ec06dcfe2100c1fa3'}\n\n```{.r .cell-code}\nhc_andersen_count %>% \n  slice_max(order_by = n, n = 10) %>% \n  mutate(word = factor(word)) %>% \n  ggplot() +\n  aes(y = reorder(word, n), x = n) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![Die häufigsten Wörter in H.C. Anderssens Feuerzeug](textmining1_files/figure-html/fig-hc-andersen-count-1.png){#fig-hc-andersen-count width=672}\n:::\n:::\n\n\n\nDabei macht es Sinn, aus `word` einen Faktor zu machen,\ndenn Faktorstufen kann man sortieren,\nzumindest ist das die einfachste Lösung in `ggplot2` (wenn auch nicht super komfortabel).\n\n\nEine (beliebite?) Methode, um Worthäufigkeiten in Corpora darzustellen, \nsind *Wortwolken*, s. @fig-wordcloud1.\nEs sei hinzugefügt, dass solche Wortwolken nicht gerade optimale\nperzeptorische Qualitäten aufweisen.\n\n\n::: {.cell hash='textmining1_cache/html/fig-wordcloud1_3c7d5f73eda022ace7aa2fa18e5904ee'}\n\n```{.r .cell-code}\nwordcloud(words = hc_andersen_count$word,\n          freq = hc_andersen_count$n,\n          max.words = 50,\n          rot.per = 0.35,\n          colors = brewer.pal(8, \"Dark2\"))\n```\n\n::: {.cell-output-display}\n![Eine Wortwolke zu den häufigsten Wörtern in H.C. Andersens Feuerzeug](textmining1_files/figure-html/fig-wordcloud1-1.png){#fig-wordcloud1 width=672}\n:::\n:::\n\n\n\n\n### Stemming (Wortstamm finden)\n\nErarbeiten Sie dieses Kapitel: @smltar, [Kap. 4](https://smltar.com/stemming.html#stemming)\n\n\nVertiefende Hinweise zum *UpSet plot* finden Sie [hier](https://ieeexplore.ieee.org/document/6876017), @lex_upset_2014.\n\n\nFür welche Sprachen gibt es Stemming im Paket `SnowballC`?\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-7_fc8180c9c2f93f6517c56eec5ff2bef2'}\n\n```{.r .cell-code}\nlibrary(SnowballC)\ngetStemLanguages()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"arabic\"     \"basque\"     \"catalan\"    \"danish\"     \"dutch\"     \n [6] \"english\"    \"finnish\"    \"french\"     \"german\"     \"greek\"     \n[11] \"hindi\"      \"hungarian\"  \"indonesian\" \"irish\"      \"italian\"   \n[16] \"lithuanian\" \"nepali\"     \"norwegian\"  \"porter\"     \"portuguese\"\n[21] \"romanian\"   \"russian\"    \"spanish\"    \"swedish\"    \"tamil\"     \n[26] \"turkish\"   \n```\n:::\n:::\n\n\n\nEinfacher Test: Suchen wir den Wordstamm für das Wort \"wissensdurstigen\", wie in \"die wissensdurstigen Studentis löcherten dis armi Professi\"^[[Gender-i](https://gender-i.de/#mit-bestimmtem-artikel)].\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-8_3ca0a28df16a342d22e728de613cf10d'}\n\n```{.r .cell-code}\nwordStem(\"wissensdurstigen\", language = \"german\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wissensdurst\"\n```\n:::\n:::\n\n\n\nWerfen Sie mal einen Blick in das Handbuch von [SnowballC](https://cran.r-project.org/web/packages/SnowballC/SnowballC.pdf).\n\n\n\n### Fallstudie AfD-Parteiprogramm\n\n\n\nDaten einlesen:\n\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-9_a7833140de147171123b127987553461'}\n\n```{.r .cell-code}\nd_link <- \"https://raw.githubusercontent.com/sebastiansauer/pradadata/master/data-raw/afd_2022.csv\"\nafd <- read_csv(d_link, show_col_types = FALSE)\n```\n:::\n\n\nWie viele Seiten hat das Dokument?\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-10_ff75e741a4331e3f73413dfa2ae12221'}\n\n```{.r .cell-code}\nnrow(afd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 190\n```\n:::\n:::\n\n\nUnd wie viele Wörter?\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-11_12ba0484e88e9fbe879b5be307d35f4b'}\n\n```{.r .cell-code}\nstr_count(afd$text, pattern = \"\\\\w\") %>% sum(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 179375\n```\n:::\n:::\n\n\n\n\nAus breit mach lang, oder: wir tokenisieren (nach Wörtern): \n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-12_9613d83bd52f79436ac093c3371492a5'}\n\n```{.r .cell-code}\nafd %>% \n  unnest_tokens(output = token, input = text) %>% \n  filter(str_detect(token, \"[a-z]\")) -> afd_long\n```\n:::\n\n\n\nStopwörter entfernen:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-13_fcd2b777cf53fa3c864990314fb99abb'}\n\n```{.r .cell-code}\ndata(stopwords_de, package = \"lsa\")\n\nstopwords_de <- tibble(word = stopwords_de)\n\n# Für das Joinen werden gleiche Spaltennamen benötigt:\nstopwords_de <- stopwords_de %>% \n  rename(token = word)  \n\nafd_long %>% \n  anti_join(stopwords_de) -> afd_no_stop\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"token\"\n```\n:::\n:::\n\n\n\nWörter zählen:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-14_75c2db6d353587f0e66cd7efd6fb2085'}\n\n```{.r .cell-code}\nafd_no_stop %>% \n  count(token, sort = TRUE) -> afd_count\n\nhead(afd_count)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|token       |   n|\n|:-----------|---:|\n|afd         | 174|\n|deutschland | 113|\n|wollen      |  66|\n|euro        |  60|\n|bürger      |  57|\n|eu          |  54|\n\n</div>\n:::\n:::\n\n\n\nWörter trunkieren:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-15_3e8d436928338af1249eecf4a76f7cf6'}\n\n```{.r .cell-code}\nafd_no_stop %>% \n  mutate(token_stem = wordStem(token, language = \"de\")) %>% \n  count(token_stem, sort = TRUE) -> afd_count_stemmed\n\nhead(afd_no_stop)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| page|token              |\n|----:|:------------------|\n|    1|programm           |\n|    1|deutschland        |\n|    1|grundsatzprogramm  |\n|    1|alternative        |\n|    1|deutschland        |\n|    2|inhaltsverzeichnis |\n\n</div>\n:::\n:::\n\n\n\n\n### Stringverarbeitung\n\n\n\nErarbeiten Sie dieses Kapitel: @r4ds, [Kap. 14](https://r4ds.had.co.nz/strings.html)\n\n\n\n#### Regulärausdrücke {#regex}\n\nDas `\"[a-z]\"` in der Syntax oben steht für \"alle Buchstaben von a-z\". D\niese flexible Art von \"String-Verarbeitung mit Jokern\" nennt man *Regulärausdrücke* (regular expressions; regex). \nEs gibt eine ganze Reihe von diesen Regulärausdrücken, die die Verarbeitung von Texten erleichert. \nMit dem Paket `stringr` geht das - mit etwas Übung - gut von der Hand. \nNehmen wir als Beispiel den Text eines Tweets:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-16_11848d099811bd31b05660100b2c4e17'}\n\n```{.r .cell-code}\nstring <- \"Correlation of unemployment and #AfD votes at #btw17: ***r = 0.18***\\n\\nhttps://t.co/YHyqTguVWx\"  \n```\n:::\n\n\nMöchte man Ziffern identifizieren, so hilft der Reulärausdruck `[:digit:]`:\n\n\"Gibt es mindestens eine Ziffer in dem String?\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-17_c6aab1a9e8c4196219c2d22a480210cf'}\n\n```{.r .cell-code}\nstr_detect(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\"Finde die Position der ersten Ziffer! Welche Ziffer ist es?\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-18_ab69150a8fc91ef1079eca837ace64b8'}\n\n```{.r .cell-code}\nstr_locate(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     start end\n[1,]    51  51\n```\n:::\n\n```{.r .cell-code}\nstr_extract(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"\n```\n:::\n:::\n\n\n\"Finde alle Ziffern!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-19_b4bed49595c5e4487bc21e64a03063ee'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"[:digit:]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"1\" \"7\" \"0\" \"1\" \"8\"\n```\n:::\n:::\n\n\n\n\"Finde alle Stellen an denen genau 2 Ziffern hintereinander folgen!\"\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-20_69856ea51a9a3041ab82cf0cdc903115'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"[:digit:]{2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"17\" \"18\"\n```\n:::\n:::\n\n\nDer Quantitätsoperator `{n}` findet alle Stellen, in der der der gesuchte Ausdruck genau $n$ mal auftaucht.\n\n\n\"Zeig die Hashtags!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-21_07c53b41d97d090b276a28ecb5e78862'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"#[:alnum:]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"#AfD\"   \"#btw17\"\n```\n:::\n:::\n\n\nDer Operator `[:alnum:]` steht für \"alphanumerischer Charakter\" - also eine Ziffer oder ein Buchstabe; synonym hätte man auch `\\\\w` schreiben können (w wie word). Warum werden zwei Backslashes gebraucht? Mit `\\\\w` wird signalisiert, dass nicht der Buchstabe *w*, sondern etwas Besonderes, eben der Regex-Operator `\\w` gesucht wird. \n\n\"Zeig die URLs!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-22_563e3a7cd574ddd30d719d9feb8cba1c'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"https?://[:graph:]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"https://t.co/YHyqTguVWx\"\n```\n:::\n:::\n\n\nDas Fragezeichen `?` ist eine Quantitätsoperator, der einen Treffer liefert, wenn das vorherige Zeichen (hier *s*) null oder einmal gefunden wird. `[:graph:]` ist die Summe von `[:alpha:]` (Buchstaben, groß und klein), `[:digit:]` (Ziffern) und `[:punct:]` (Satzzeichen u.ä.).\n\n\"Zähle die Wörter im String!\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-23_d6272b3e2681d13ff1ef7132f4977c6c'}\n\n```{.r .cell-code}\nstr_count(string, boundary(\"word\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n:::\n\n\n\n\"Liefere nur Buchstaben*folgen* zurück, lösche alles übrige\"\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-24_e9832a656f26f2700232effb461af34a'}\n\n```{.r .cell-code}\nstr_extract_all(string, \"[:alpha:]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Correlation\"  \"of\"           \"unemployment\" \"and\"          \"AfD\"         \n [6] \"votes\"        \"at\"           \"btw\"          \"r\"            \"https\"       \n[11] \"t\"            \"co\"           \"YHyqTguVWx\"  \n```\n:::\n:::\n\n\nDer Quantitätsoperator `+` liefert alle Stellen zurück, in denen der gesuchte Ausdruck *einmal oder häufiger*  vorkommt. Die Ergebnisse werden als Vektor von Wörtern zurückgegeben. Ein anderer Quantitätsoperator ist `*`, der für 0 oder mehr Treffer steht. Möchte man einen Vektor, der aus Stringen-Elementen besteht zu einem Strring zusammenfüngen, hilft `paste(string)` oder `str_c(string, collapse = \" \")`.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-25_3f23cdf821e6c6ea6c8e894588cf1de1'}\n\n```{.r .cell-code}\nstr_replace_all(string, \"[^[:alpha:]+]\", \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CorrelationofunemploymentandAfDvotesatbtwrhttpstcoYHyqTguVWx\"\n```\n:::\n:::\n\n\nMit dem Negationsoperator `[^x]` wird der Regulärausrck `x` negiert; die Syntax oben heißt also \"ersetze in `string` alles außer Buchstaben durch Nichts\". Mit \"Nichts\" sind hier Strings der Länge Null gemeint; ersetzt man einen belieibgen String durch einen String der Länge Null, so hat man den String gelöscht.\n\nDas Cheatsheet zur Strings bzw zu `stringr` von RStudio gibt einen guten Überblick über Regex; im Internet finden sich viele Beispiele.\n\n\n\n\n\n\n\n\n\n\n#### Regex im Texteditor\n\n\nEinige Texteditoren unterstützen Regex, so auch RStudio.\n\nDas ist eine praktische Sache. \nEin Beispiel: Sie haben eine Liste mit Namen der Art:\n\n- Nachname1, Vorname1\n- Nachname2, Vorname2\n- Nachname3, Vorname3\n\n\nUnd Sie möchten jetzt aber die Liste mit Stil *Vorname Nachname* sortiert haben.\n\nRStudio mit Regex macht's möglich, s. @fig-vorher-regex.\n\n\n::: {#fig-regrex-rstudio}\n\n![Vorher; mit Regex-Syntax](img/regex1.png){#fig-vorher-regex}\n![Vorher; mit Regex-Syntax](img/regex2.png){#fig-nacher-regex}\n\n:::\n\n\n\n\n\n### Emoji-Analyse\n\nEine einfache Art, Emojis in einer Textmining-Analyse zu verarbeiten, \nbietet das Paket `textclean`:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-26_3544cff4f7ada37b3a70203a3ba2073b'}\n\n```{.r .cell-code}\nfls <- system.file(\"docs/emoji_sample.txt\", package = \"textclean\")\nx <- readLines(fls)[1]\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Proin 😍 ut maecenas 😏 condimentum 😔 purus eget. Erat, 😂vitae nunc elit. Condimentum 😢 semper iaculis bibendum sed tellus. Ut suscipit interdum😑 in. Faucib😞 us nunc quis a vitae posuere. 😛 Eget amet sit condimentum non. Nascetur vitae ☹ et. Auctor ornare ☺ vestibulum primis justo congue 😀urna ac magna. Quam 😥 pharetra 😟 eros 😒facilisis ac lectus nibh est 😙vehicula 😐 ornare! Vitae, malesuada 😎 erat sociosqu urna, 😏 nec sed ad aliquet 😮 .\"\n```\n:::\n:::\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-27_561e378ff4a7143199c8cb2d3d36c003'}\n\n```{.r .cell-code}\nreplace_emoji(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Proin smiling face with heart-eyes ut maecenas smirking face condimentum pensive face purus eget. Erat, face with tears of joy vitae nunc elit. Condimentum crying face semper iaculis bibendum sed tellus. Ut suscipit interdum expressionless face in. Faucib disappointed face us nunc quis a vitae posuere. face with tongue Eget amet sit condimentum non. Nascetur vitae frowning face et. Auctor ornare smiling face vestibulum primis justo congue grinning face urna ac magna. Quam sad but relieved face pharetra worried face eros unamused face facilisis ac lectus nibh est kissing face with smiling eyes vehicula neutral face ornare! Vitae, malesuada smiling face with sunglasses erat sociosqu urna, smirking face nec sed ad aliquet face with open mouth .\"\n```\n:::\n\n```{.r .cell-code}\nreplace_emoji_identifier(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Proin lexiconwiutsdotskrupggpgmhm ut maecenas lexiconwizbukzesopzflfinotj condimentum lexiconwlnxqescoesytfatoevi purus eget. Erat, lexiconwcaiviebiytolowkanmb vitae nunc elit. Condimentum lexiconwpujksvgujncexktvyrn semper iaculis bibendum sed tellus. Ut suscipit interdum lexiconwknnasgueiicggptyzbx in. Faucib lexiconwoxfeslcareuqfkbyjgy us nunc quis a vitae posuere. lexiconwobmhqdrrzgygdexhnkk Eget amet sit condimentum non. Nascetur vitae lexiconbfalxvockmnmtmycmwyq et. Auctor ornare lexiconbgmujofaalvxqrklfqgd vestibulum primis justo congue lexiconvygwtlyrpywfarytvfis urna ac magna. Quam lexiconwurhpvewhizayynmfxqo pharetra lexiconwpmuduwgbxxrxeltrueb eros lexiconwkrvakxddtqckcjxeksl facilisis ac lectus nibh est lexiconwmsjgfnelqfeyhgudmfj vehicula lexiconwjfhkpcsgcjtotwlapxa ornare! Vitae, malesuada lexiconwivnupleicqgksianinp erat sociosqu urna, lexiconwizbukzesopzflfinotj nec sed ad aliquet lexiconxbwhfeflxbuupjezgdwl .\"\n```\n:::\n:::\n\n\n\n\n\n### Text aufräumen\n\nEine Reihe generischer Tests bietet das Paket `textclean` von [Tyler Rinker](https://github.com/trinker/textclean):\n\n\nHier ist ein \"unaufgeräumeter\" Text:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-28_1d7b61740c8e10c347fab6504f364a51'}\n\n```{.r .cell-code}\nx <- c(\"i like\", \"<p>i want. </p>. thet them ther .\", \"I am ! that|\", \"\", NA, \n    \"&quot;they&quot; they,were there\", \".\", \"   \", \"?\", \"3;\", \"I like goud eggs!\", \n    \"bi\\xdfchen Z\\xfcrcher\", \"i 4like...\", \"\\\\tgreat\",  \"She said \\\"yes\\\"\")\n```\n:::\n\n\n\n\nLassen wir uns dazu ein paar Diagnostiken ausgeben.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-29_fbc8f139c6ec31fb4b01451d72065e4a'}\n\n```{.r .cell-code}\nEncoding(x) <- \"latin1\"\nx <- as.factor(x)\ncheck_text(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n=============\nNON CHARACTER\n=============\n\nThe text variable is not a character column (likely `factor`):\n\n\n*Suggestion: Consider using `as.character` or `stringsAsFactors = FALSE` when reading in\n             Also, consider rerunning `check_text` after fixing\n\n\n=====\nDIGIT\n=====\n\nThe following observations contain digits/numbers:\n\n10, 13\n\nThis issue affected the following text:\n\n10: 3;\n13: i 4like...\n\n*Suggestion: Consider using `replace_number`\n\n\n========\nEMOTICON\n========\n\nThe following observations contain emoticons:\n\n6\n\nThis issue affected the following text:\n\n6: &quot;they&quot; they,were there\n\n*Suggestion: Consider using `replace_emoticons`\n\n\n=====\nEMPTY\n=====\n\nThe following observations contain empty text cells (all white space):\n\n1\n\nThis issue affected the following text:\n\n1: i like\n\n*Suggestion: Consider running `drop_empty_row`\n\n\n=======\nESCAPED\n=======\n\nThe following observations contain escaped back spaced characters:\n\n14\n\nThis issue affected the following text:\n\n14: \\tgreat\n\n*Suggestion: Consider using `replace_white`\n\n\n====\nHTML\n====\n\nThe following observations contain HTML markup:\n\n2, 6\n\nThis issue affected the following text:\n\n2: <p>i want. </p>. thet them ther .\n6: &quot;they&quot; they,were there\n\n*Suggestion: Consider running `replace_html`\n\n\n==========\nINCOMPLETE\n==========\n\nThe following observations contain incomplete sentences (e.g., uses ending punctuation like '...'):\n\n13\n\nThis issue affected the following text:\n\n13: i 4like...\n\n*Suggestion: Consider using `replace_incomplete`\n\n\n=============\nMISSING VALUE\n=============\n\nThe following observations contain missing values:\n\n5\n\n*Suggestion: Consider running `drop_NA`\n\n\n========\nNO ALPHA\n========\n\nThe following observations contain elements with no alphabetic (a-z) letters:\n\n4, 7, 8, 9, 10\n\nThis issue affected the following text:\n\n4: \n7: .\n8:    \n9: ?\n10: 3;\n\n*Suggestion: Consider cleaning the raw text or running `filter_row`\n\n\n==========\nNO ENDMARK\n==========\n\nThe following observations contain elements with missing ending punctuation:\n\n1, 3, 4, 6, 8, 10, 12, 14, 15\n\nThis issue affected the following text:\n\n1: i like\n3: I am ! that|\n4: \n6: &quot;they&quot; they,were there\n8:    \n10: 3;\n12: bißchen Zürcher\n14: \\tgreat\n15: She said \"yes\"\n\n*Suggestion: Consider cleaning the raw text or running `add_missing_endmark`\n\n\n====================\nNO SPACE AFTER COMMA\n====================\n\nThe following observations contain commas with no space afterwards:\n\n6\n\nThis issue affected the following text:\n\n6: &quot;they&quot; they,were there\n\n*Suggestion: Consider running `add_comma_space`\n\n\n=========\nNON ASCII\n=========\n\nThe following observations contain non-ASCII text:\n\n12\n\nThis issue affected the following text:\n\n12: bißchen Zürcher\n\n*Suggestion: Consider running `replace_non_ascii`\n\n\n==================\nNON SPLIT SENTENCE\n==================\n\nThe following observations contain unsplit sentences (more than one sentence per element):\n\n2, 3\n\nThis issue affected the following text:\n\n2: <p>i want. </p>. thet them ther .\n3: I am ! that|\n\n*Suggestion: Consider running `textshape::split_sentence`\n```\n:::\n:::\n\n\n\n\n\n### Diverse Wortlisten\n\n\n[Tyler Rinker](https://github.com/trinker/lexicon) stellt mit dem Paket `lexicon` eine Zusammenstellung von Wortlisten zu diversen Zwecken zur Verfügung.\nAllerding nur für die englische Sprache.\n\n\n\n\n\n\n### Sentimentanalyse {#sec-sentimentanalyse}\n\n\n#### Einführung\n\n\nEine weitere interessante Analyse ist, die \"Stimmung\" oder \"Emotionen\" (Sentiments) eines Textes auszulesen. \nDie Anführungszeichen deuten an, dass hier ein Maß an Verständnis suggeriert wird, welches nicht (unbedingt) von der Analyse eingehalten wird. \nJedenfalls ist das Prinzip der Sentiment-Analyse im einfachsten Fall so: \n\n\n\n\n\n1. Schau dir jeden Token aus dem Text an.  \n2. Prüfe, ob sich das Wort im Lexikon der Sentiments wiederfindet.  \n3. Wenn ja, dann addiere den Sentimentswert dieses Tokens zum bestehenden Sentiments-Wert.  \n4. Wenn nein, dann gehe weiter zum nächsten Wort.  \n5. Liefere zum Schluss die Summenwerte pro Sentiment zurück.  \n\n\n\n\n     \nEs gibt Sentiment-Lexika, die lediglich einen Punkt für \"positive Konnotation\" bzw. \"negative Konnotation\" geben; andere Lexiko weisen differenzierte Gefühlskonnotationen auf. Wir nutzen hier das *deutsche* Sentimentlexikon `sentiws` [@Remus2010]. Sie können das Lexikon als CSV hier herunterladen:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-30_00d41c0855658e445e91666af1480c2d'}\n\n```{.r .cell-code}\nsentiws <- read_csv(\"https://osf.io/x89wq/?action=download\")\n```\n:::\n\n\n\nDen Volltext zum Paper finden Sie z.B. [hier](http://www.lrec-conf.org/proceedings/lrec2010/pdf/490_Paper.pdf).\n\nAlternativ können Sie die Daten aus dem Paket `pradadata` laden. Allerdings müssen Sie dieses Paket von Github installieren:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-31_b66d7cbd332c384e9e6a63072242e69d'}\n\n```{.r .cell-code}\ninstall.packages(\"devtools\", dep = TRUE)\ndevtools::install_github(\"sebastiansauer/pradadata\")\n```\n:::\n\n::: {.cell hash='textmining1_cache/html/parse-sentiment-dics_7b392074be7f9e2faa3b256a45bdc064'}\n\n```{.r .cell-code}\ndata(sentiws, package = \"pradadata\")\n```\n:::\n\n\n@tbl-afdcount zeigt einen Ausschnitt aus dem Sentiment-Lexikon *SentiWS*.\n\n\n::: {#tbl-afdcount .cell tbl-cap='Auszug aus SentiWS' hash='textmining1_cache/html/tbl-afdcount_65282fac3f90acfc5d9eab2b6e2ed3a2'}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|neg_pos |word       |   value|inflections                           |\n|:-------|:----------|-------:|:-------------------------------------|\n|neg     |Abbau      | -0.0580|Abbaus,Abbaues,Abbauen,Abbaue         |\n|neg     |Abbruch    | -0.0048|Abbruches,Abbrüche,Abbruchs,Abbrüchen |\n|neg     |Abdankung  | -0.0048|Abdankungen                           |\n|neg     |Abdämpfung | -0.0048|Abdämpfungen                          |\n|neg     |Abfall     | -0.0048|Abfalles,Abfälle,Abfalls,Abfällen     |\n|neg     |Abfuhr     | -0.3367|Abfuhren                              |\n\n</div>\n:::\n:::\n\n\n\n#### Ungewichtete Sentiment-Analyse\n\nNun können wir jedes Token des Textes mit dem Sentiment-Lexikon abgleichen; \ndabei zählen wir die Treffer für positive bzw. negative Terme. \nZuvor müssen wir aber noch die Daten (`afd_long`) mit dem Sentimentlexikon zusammenführen (joinen). \nDas geht nach bewährter Manier mit `inner_join`; \"inner\" sorgt dabei dafür, dass nur Zeilen behalten werden, die in beiden Dataframes vorkommen. Tabelle @tbl-afdsenti zeigt Summe, Anzahl und Anteil der Emotionswerte.\n\n\nWir nutzen die Tabelle `afd_long`,  die wir oben definiert haben.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-32_f988accdf275dca7db6310ee3ffb2773'}\n\n```{.r .cell-code}\nafd_long %>% \n  inner_join(sentiws, by = c(\"token\" = \"word\")) %>% \n  select(-inflections) -> afd_senti  # die Spalte brauchen wir nicht\n\nafd_senti %>% \n  group_by(neg_pos) %>% \n  summarise(polarity_sum = sum(value),\n            polarity_count = n()) %>% \n  mutate(polarity_prop = (polarity_count / sum(polarity_count)) %>% round(2)) ->\n  afd_senti_tab\n```\n:::\n\n::: {#tbl-afdsenti .cell tbl-cap='Zusammenfassung von SentiWS' hash='textmining1_cache/html/tbl-afdsenti_696f0b6db6c35d405ff61879bfb85427'}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|neg_pos | polarity_sum| polarity_count| polarity_prop|\n|:-------|------------:|--------------:|-------------:|\n|neg     |     -48.5307|            210|          0.27|\n|pos     |      30.6595|            578|          0.73|\n\n</div>\n:::\n:::\n\n\n\nDie Analyse zeigt, dass die emotionale Bauart des Textes durchaus interessant ist: \nEs gibt viel mehr positiv getönte Wörter als negativ getönte. \nAllerdings sind die negativen Wörter offenbar deutlich stärker emotional aufgeladen, \ndenn die Summe an Emotionswert der negativen Wörter ist (überraschenderweise?) deutlich größer als die der positiven.\n\nBetrachten wir also die intensivsten negativ und positive konnotierten Wörter näher.\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-33_e630ea50155dad425d47d2c1bac72db2'}\n\n```{.r .cell-code}\nafd_senti %>% \n  distinct(token, .keep_all = TRUE) %>% \n  mutate(value_abs = abs(value)) %>% \n  top_n(20, value_abs) %>% \n  pull(token)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"ungerecht\"    \"besonders\"    \"gefährlich\"   \"überflüssig\"  \"behindern\"   \n [6] \"gelungen\"     \"brechen\"      \"unzureichend\" \"gemein\"       \"verletzt\"    \n[11] \"zerstören\"    \"trennen\"      \"falsch\"       \"vermeiden\"    \"zerstört\"    \n[16] \"schwach\"      \"belasten\"     \"schädlich\"    \"töten\"        \"verbieten\"   \n```\n:::\n:::\n\n\nDiese \"Hitliste\" wird zumeist (19/20) von negativ polarisierten Begriffen aufgefüllt, \nwobei \"besonders\" ein Intensivierwort ist, welches das Bezugswort verstärt (\"besonders gefährlich\"). \nDas Argument `keep_all = TRUE` sorgt dafür, dass alle Spalten zurückgegeben werden, \nnicht nur die durchsuchte Spalte `token`. \nMit `pull` haben wir aus dem Dataframe, der von den dplyr-Verben übergeben wird, \ndie Spalte `pull` \"herausgezogen\"; \nhier nur um Platz zu sparen bzw. der Übersichtlichkeit halber.\n\n\n     \nNun könnte man noch den erzielten \"Netto-Sentimentswert\" des Corpus ins Verhältnis setzen Sentimentswert des Lexikons:\nWenn es insgesamt im Sentiment-Lexikon sehr negativ zuginge,\nwäre ein negativer Sentimentwer in einem beliebigen Corpus nicht überraschend. `describe_distribution` aus `{easystats}` gibt uns einen Überblick der üblichen deskriptiven Statistiken.\n     \n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-34_638b2c9714b4d9e0b9ad2ca7e4bc0c9e'}\n\n```{.r .cell-code}\nsentiws %>% \n  select(value, neg_pos) %>% \n  #group_by(neg_pos) %>% \n  describe_distribution()\n```\n:::\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-35_8c6419082d4792976e196788ba4ebc87'}\n::: {.cell-output-display}\n|Variable |  Mean |   SD |  IQR |         Range | Skewness | Kurtosis |    n | n_Missing |\n|:--------|:-----:|:----:|:----:|:-------------:|:--------:|:--------:|:----:|:---------:|\n|value    | -0.05 | 0.20 | 0.05 | (-1.00, 1.00) |    -0.68 |     2.36 | 3468 |         0 |\n:::\n:::\n\n\nInsgesamt ist das Lexikon ziemlich ausgewogen; negative Werte sind leicht in der Überzahl im Lexikon. \nUnser Corpus hat eine ähnliche mittlere emotionale Konnotation wie das Lexikon:\n\n\n::: {.cell hash='textmining1_cache/html/unnamed-chunk-36_62e1fc94513ca3b8970f67ecb1beff54'}\n\n```{.r .cell-code}\nafd_senti %>% \n  summarise(senti_sum = mean(value) %>% round(2))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| senti_sum|\n|---------:|\n|     -0.02|\n\n</div>\n:::\n:::\n\n\n\n\n### Weitere Sentiment-Lexika\n\n[Tyler Rinker](https://github.com/trinker/sentimentr) stellt das Paket `sentimentr` zur Verfügung.\n[Matthew Jockers](https://www.matthewjockers.net/2015/02/02/syuzhet/) stellt das Paket `Syushet` zur Verfügung.\n\n\n\n### Google Trends\n\nEine weitere Möglichkeit, \"Worthäufigkeiten\" zu identifizieren ist [Google Trends](https://trends.google.com/trends/?geo=US).\nDieser Post zeigt Ihnen eine Einsatzmöglichkeit.\n\n\n\n\n## Aufgaben\n\n\n- [purrr-map01](https://datenwerk.netlify.app/posts/purrr-map01/purrr-map01.html)\n- [purrr-map02](https://datenwerk.netlify.app/posts/purrr-map02/purrr-map02.html)\n- [purrr-map03](https://datenwerk.netlify.app/posts/purrr-map03/purrr-map03.html)\n- [purrr-map04](https://datenwerk.netlify.app/posts/purrr-map04/purrr-map04.html)\n- [Regex-Übungen](https://regexone.com/)\n- [Aufgaben zum Textmining von Tweets](https://datenwerk.netlify.app/#category=textmining)\n\n\n\n\n## Fallstudie Hate-Speech\n\n\n### Daten\n\nEs finden sich mehrere Datensätze zum Thema Hate-Speech im öffentlichen Internet, eine Quelle ist [Hate Speech Data](https://ckan.hatespeechdata.com/), ein Repositorium, das mehrere Datensätze beinhaltet.\n\n\n\n- [Kaggle Hate Speech and Offensive Language Dataset](https://www.kaggle.com/datasets/mrmorj/hate-speech-and-offensive-language-dataset?select=labeled_data.csv)\n- [Bretschneider and Peters Prejudice on Facebook Dataset](https://ckan.hatespeechdata.com/dataset/bretschneider-and-peters-prejudice-on-facebook-dataset)\n- [Daten zum Fachartikel\"Large Scale Crowdsourcing and Characterization of Twitter Abusive Behavior\"](https://github.com/ENCASEH2020/hatespeech-twitter/blob/master/hatespeech_labels.csv)\n\n\nFür Textmining kann eine Liste mit anstößigen (obszönen) Wörten nützlich sein,\nauch wenn man solche Dinge ungern anfässt, verständlicherweise.\n[Jenyay](https://github.com/Jenyay/Obscene-Words-List) bietet solche Listen in verschiedenen Sprachen an. Die Liste von [KDNOOBW](https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words) sieht sehr ähnlich aus (zumindest die deutsche Version).\nEine lange Sammlung deutscher Schimpfwörter findet sich im [insult.wiki](https://www.insult.wiki/schimpfwort-liste);\nähnlich bei [Hyperhero](http://www.hyperhero.com/de/insults.htm).\n\n\n\n\n\n\n\nTwitterdaten dürfen nur in \"dehydrierter\" Form weitergegeben werden, so dass kein Rückschluss von ID zum Inhalt des Tweets möglich ist. \nDaher werden öffentlich nur die IDs der Tweets, als einzige Information zum Tweet, also ohne den eigentlichen Inhalt des Tweets, bereitgestellt.\n\nÜber die Twitter-API kann man sich, wie oben dargestellt, dann die Tweets wieder \"rehydrieren\", also wieder mit dem zugehörigen Tweet-Text (und sonstigen Infos des Tweets) zu versehen.\n\n\n\n\n### Grundlegendes Text Mining\n\n\nWenden Sie die oben aufgeführten Techniken des grundlegenden Textminings auf einen der oben dargestellten Hate-Speech-Datensätze an.\nErstellen Sie ein (HTML-Dokument) mit Ihren Ergebnissen. \nStellen Sie die Ergebnisse auf dem Github-Repo dieses Kurses ein.\nVergleichen Sie Ihre Lösung mit den Lösungen der anderen Kursmitglieder.\n\nWir nutzen noch nicht eigene Daten, die wir von Twitter ausgelesen haben, das heben wir uns für später auf.\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}