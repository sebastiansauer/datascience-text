{
  "hash": "f3b34c6026956ddce9c13b7b3db9f094",
  "result": {
    "markdown": "# Fallstudie Hatespeech\n\n\n\n\nWir sagen vorher, welche Tweets an führende deutsche Politikis Hassrede bzw. hasserfüllte Rede enthalten.\n\n\n## Vorab\n\n\n\n\n### Lernziele\n\n\n- Sie können grundlegende Verfahren zur Klassifikation von Hatespeech einsetzen und erklären\n- Sie können mit echten Daten umgehen im Sinne eines Projektmanagement von Data Science\n\n\n\n\n\n\n\n\n### Benötigte R-Pakete\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-1_d7d3f9112134d2fb3084676a6f68e982'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(easystats)\nlibrary(tidytext)\nlibrary(textrecipes)\nlibrary(tictoc)  # Zeitmessung\nlibrary(beepr)  # piebt, wenn fertig\nlibrary(remoji)  # Emojis\nlibrary(feather)  # Daten speichern\nlibrary(pradadata)  # Hilfsdaten wie Schimpfwoerter\nlibrary(lubridate)  # Datum und Zeit\nlibrary(tokenizers)\nlibrary(feather)  # feather data\nlibrary(pradadata)  # helper data\nlibrary(remoji)  # processing emojis\n```\n:::\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-2_31c4315ea9fff138a2a6ce9921a436de'}\n\n:::\n\n\n\n## Daten\n\n\n### Train- und Testdaten\n\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-3_49b6f1ded297f4489178e75f7caf9dc0'}\n\n```{.r .cell-code}\nd1 <- read_rds(\"objects/d1.rds\")  # Traindaten einlesen\n```\n:::\n\n\n\nIn Train- und Test-Datensatz aufsplitten:\n\n\n::: {.cell hash='hatespeech2_cache/html/d-split-d1_96f10b7044dd06d6318641ee60ce101c'}\n\n```{.r .cell-code}\nd_split <- initial_split(d1, strata = c1)\n\nd_train <- training(d_split)\nd_test <- testing(d_split)\n```\n:::\n\n\n\n\n\n\n\n### Vorhersagedaten\n\nWir importieren die Tweets führender deutscher Politikis.\n\nFür diese Daten haben wir keine Werte der Zielvariablen. \nWir können nur vorhersagen,\naber nicht unsere Modellgüte berechnen.\nDiese Daten bezeichnen wir als *Vorhersagedaten*.\n\n\n\nPfad zu den Daten:\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-4_d2041f8c53d79bcb381277a0d676a602'}\n\n```{.r .cell-code}\ntweet_data_path <- \"/Users/sebastiansaueruser/github-repos/hate-speech/data-raw/tweets-small\"\n\nfile.exists(tweet_data_path)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nDie Nutzungsrechte von Twitter erlauben nicht, diese Daten öffentlich zu teilen.\n\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-5_4304a4ac3f9ae501a9ef42142e19c2fd'}\n\n```{.r .cell-code}\ntweet_data_files_names <-\n  list.files(\n    path = tweet_data_path,\n    full.names = TRUE,\n    pattern = \".rds\")\n\n\nnames(tweet_data_files_names) <-  \n  list.files(\n    path = tweet_data_path,\n    full.names = FALSE,\n    pattern = \".rds\") %>% \n  str_remove(\".rds$\") %>% \n  str_remove(\"^tweets-to-\")\n\ntweet_data_files_names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                                                                                   BMWK_2021 \n          \"/Users/sebastiansaueruser/github-repos/hate-speech/data-raw/tweets-small/tweets-to-BMWK_2021.rds\" \n                                                                                         Janine_Wissler_2021 \n\"/Users/sebastiansaueruser/github-repos/hate-speech/data-raw/tweets-small/tweets-to-Janine_Wissler_2021.rds\" \n                                                                                         Janine_Wissler_2022 \n\"/Users/sebastiansaueruser/github-repos/hate-speech/data-raw/tweets-small/tweets-to-Janine_Wissler_2022.rds\" \n```\n:::\n:::\n\n\n\n\nSo lesen wir alle Dateien aus diesem Ordner ein.\nZunächst erstellen wir uns eine Helper-Funktion:\n\n\n\n::: {.cell hash='hatespeech2_cache/html/source-fun-read-and-select_58e7ed99426e0ecc5fad9685edd5d2a5'}\n\n```{.r .cell-code}\nsource(\"funs/read-and-select.R\")\n```\n:::\n\n\n\n\nDie Funktion `read_and_select`  mappen wir auf alle Datendateien:\n\n\n\n::: {.cell hash='hatespeech2_cache/html/map-read-and-select_d1929ca3dea1950260c69a4f4b74a6d6'}\n\n```{.r .cell-code}\ntic()\nds <-\n  tweet_data_files_names %>% \n  map_dfr(read_and_select, .id = \"dataset\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData file was read.\nData file was read.\nData file was read.\n```\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.73 sec elapsed\n```\n:::\n:::\n\n\n\nEin Blick zur Probe:\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-6_f3ddea06398c395b96044cd28fbc05c0'}\n\n```{.r .cell-code}\nds %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 10,310\nColumns: 9\n$ dataset       <chr> \"BMWK_2021\", \"BMWK_2021\", \"BMWK_2021\", \"BMWK_2021\", \"BMW…\n$ id            <chr> \"1476982045268185091\", \"1476948509706407942\", \"147694476…\n$ author_id     <chr> \"749510675811139585\", \"146337393\", \"841768687245918208\",…\n$ created_at    <chr> \"2021-12-31T18:22:15.000Z\", \"2021-12-31T16:08:59.000Z\", …\n$ text          <chr> \"@BMWi_Bund @twittlik @Pendolino70 @nextmove_de Richtig.…\n$ retweet_count <int> 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ reply_count   <int> 0, 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,…\n$ like_count    <int> 0, 0, 1, 0, 0, 1, 1, 3, 3, 0, 3, 0, 0, 1, 0, 0, 1, 2, 1,…\n$ quote_count   <int> 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n```\n:::\n:::\n\n\n\n\nDa wir den Elementen von `tweet_data_files_names` Namen gegeben haben, \nfinden wir diese Namen praktischerweise wieder in `ds`.\n\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-7_0e1cccb4538bbf04ef70ddda3bcceefb'}\n\n:::\n\n\n\n\n\nEine Alternative zum Format RDS besteht im Format [Feather](https://github.com/wesm/feather):\n\n>   Feather: fast, interoperable data frame storage\nFeather provides binary columnar serialization for data frames. \nIt is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy. \n\n\n\n\n\n### Worteinbettungen\n\nWie in @sec-fasttext dargestellt, importieren wir unser FastText-Modell.\n\n\n::: {.cell hash='hatespeech2_cache/html/read-fastext-twitter_7b5f200d00a4a8d98d4e056c18734bee'}\n\n```{.r .cell-code}\nword_embedding_twitter <- read_rds(file = \"/Users/sebastiansaueruser/datasets/Twitter/word_embedding_twitter.rds\")\n```\n:::\n\n\n\nWie viel Speicher benötigt das Worteinbettungsobjekt?\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-8_d91dfd319afa0da4d2fd6ef0b7dc5f2d'}\n\n```{.r .cell-code}\nformat(object.size(word_embedding_twitter), units = \"Mb\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"108.3 Mb\"\n```\n:::\n:::\n\n\n\n\n### Hilfsdaten\n\n\n::: {.cell hash='hatespeech2_cache/html/load-helper-data_12f48a13c282472477977115b826b104'}\n\n```{.r .cell-code}\ndata(\"schimpwoerter\")\ndata(\"sentiws\")\ndata(\"wild_emojis\")\n```\n:::\n\n\n\n\n## Aufbereiten der Vorhersagedaten\n\n### Hilfsfunktionen\n\n\n\n\n::: {.cell hash='hatespeech2_cache/html/source-helper-funs-recipe_3be0ae8897266eb95d4afcd32b203616'}\n\n```{.r .cell-code}\nsource(\"funs/helper-funs-recipes.R\")\n```\n:::\n\n\n\n## Rezept\n\n\nDa wir schon ein Rezept \"trainiert\" haben,\nkönnen wir die Test-Daten einfach mit dem Rezept \"backen\".\n\nStreng genommen müssten wir nicht mal das tun,\ndenn `tidymodels` würde das beim Vorhersagen für uns übernehmen.\nAber es ist nützlich, die Daten in aufbereiteter Form zu sehen,\nbzw. sie direkt zugänglich zu haben.\n\n\n\n\n::: {.cell hash='hatespeech2_cache/html/rec2_4a5fa12f263350ddc90f3b5a887b68ed'}\n\n```{.r .cell-code}\nrec2 <- \n  recipe(c1 ~ ., data = select(d_train, text, c1, id)) %>% \n  update_role(id, new_role = \"id\") %>% \n  step_text_normalization(text) %>% \n  step_mutate(text_copy = text,\n              profane_n = map_int(text_copy, count_profane, profane_list = schimpfwoerter$word),\n              emo_words_n = map_int(text_copy, count_emo_words, emo_list = sentiws$word),\n              emojis_n = map_int(text_copy, count_emojis, emoji_list = emoji(list_emoji(), pad = FALSE)),\n              wild_emojis_n = map_int(text_copy, count_wild_emojis, wild_emoji_list = wild_emojis$emojis)\n  ) %>% \n  step_textfeature(text_copy) %>% \n  step_tokenize(text, token = \"tweets\") %>% \n  step_stopwords(text, language = \"de\", stopword_source = \"snowball\") %>% \n  step_word_embeddings(text, embeddings = word_embedding_twitter)\n \nrec2\n```\n:::\n\n\n\n### Preppen und Backen\n\nPreppen:\n\n\n::: {.cell hash='hatespeech2_cache/html/rec2-prepped-baked_0988e83407c1d232966fd0abeb89da93'}\n\n```{.r .cell-code}\ntic()\nrec2_prepped <- prep(rec2)\ntoc()\n```\n:::\n\n\n\n```\n29.377 sec elapsed\n```\n\nBraucht ganz schön Zeit ...\n\n\n\n\nZur Sicherheit speichern wir auch dieses Objekt ab.\n\n\n::: {.cell hash='hatespeech2_cache/html/read-rec2-prepped_341fe12cc93d1de1ed98afc400e8e15c'}\n\n```{.r .cell-code}\n# write_rds(rec2_prepped, \"objects/rec2_prepped.rds\")\nrec2_prepped <- read_rds(\"/Users/sebastiansaueruser/datasets/Twitter/hate-classific/rec2_prepped.rds\")\n```\n:::\n\n\n\n\nAls nächstes kommt das Backen der Vorhersagedaten.\nDas ist die Stelle, an der zum ersten Mal die neuen Daten (die Vorhersagedaten) ins Spiel kommen.\n\n\n\n::: {.cell hash='hatespeech2_cache/html/bake-rec2_7ad99dda95b8ce97aa91fa701fae73c9'}\n\n```{.r .cell-code}\ntic()\nd_predict_baken <-\n  bake(rec2_prepped, new_data = ds)\n\nd_predict_baken$id <- ds$id\ntoc()\nbeepr::beep()\n```\n:::\n\n\nPuh, das Backen dauert - bei großen Datensätzen - gefühlt ewig!\nDaher ist das `beep`en praktisch:\nEs klingelt, wenn die Berechnung fertig ist.\n\n\n\n::: {.cell hash='hatespeech2_cache/html/read-predict-baken_4850cc65e47437bfab7cf85c4cfddbed'}\n\n:::\n\n\n\nZur Erinnerung: `d_predict_baken` ist der \"gebackene\" Testdatensatz.\nDer Testdatensatz also,\nauf dem die ganzen Operationen der Vorverarbeitung angewandt wurden.\n\n\n\n\n### Git Large File System\n\n\nWenn Sie Ihre Arbeit mit einem Versionierungssystem schützen - und Sie sollten es tun - \ndann verwenden Sie vermutlich Git.\nGit ist für Textdateien ausgelegt - was bei Quellcode ja auch Sinn macht,\nund für Quellcode ist Git gemacht.\nAllerdings will man manchmal auch binäre Dateien sichern,\netwa Daten im RDS-Format.\nSolche binären Formante funktionieren nicht wirklich aus der Sicht von Git,\nsie lassen sich nicht zeilenweise nachverfolgen.\nKurz gesagt sollte man sie aus diesem Grund nicht in Git nachverfolgen.\nEine bequeme Lösung ist das[ *Large File System* von Github (git lfs)](https://git-lfs.github.com/),\ndas diese großen Dateien außerhalb des Git-Index verwaltet.\nTrotzdem sieht es für Nutzis aus wie immer,\nist also sehr komfortabel.\nDazu ist es nötig, [git lfs](https://www.veit-schiele.de/dienstleistungen/technische-dokumentation/git/git-lfs) zu installieren.\n\n\n\n\n### Metadaten\n\n\nMetadaten wieder hinzufügen:\n\n\n\n::: {.cell hash='hatespeech2_cache/html/re-add-metadata3_9693d39216baf2653abba255bb91047d'}\n\n```{.r .cell-code}\nd_predict2 <-\n  d_predict_baken %>% \n  left_join(ds, by = \"id\") %>% \n  relocate(dataset, id, author_id, created_at, text, retweet_count, reply_count, quote_count, .after = id) %>% \n  mutate(id = as.integer(id))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mask$eval_all_mutate(quo): NAs introduced by coercion to integer\nrange\n```\n:::\n:::\n\n\nLeider müssen wir `id` in Integer umwandeln,\ndas wir dies im Rezept auch so gemacht hatten.\nDabei geht die Spalte kaputt, bzw. die Daten werden NA,\nda die resultierende Integerzahl zu groß für R ist.\nAber nicht so schlimm: Wir fügen sie später wieder hinzu.\n\n\nSpaltennamen mal anschauen:\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-9_e8edfbc2ebe59dd19259b68686e3083c'}\n\n```{.r .cell-code}\nnames(d_predict2)[1:33]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"dataset\"                             \"id\"                                 \n [3] \"author_id\"                           \"created_at\"                         \n [5] \"text\"                                \"retweet_count\"                      \n [7] \"reply_count\"                         \"quote_count\"                        \n [9] \"profane_n\"                           \"emo_words_n\"                        \n[11] \"emojis_n\"                            \"wild_emojis_n\"                      \n[13] \"textfeature_text_copy_n_words\"       \"textfeature_text_copy_n_uq_words\"   \n[15] \"textfeature_text_copy_n_charS\"       \"textfeature_text_copy_n_uq_charS\"   \n[17] \"textfeature_text_copy_n_digits\"      \"textfeature_text_copy_n_hashtags\"   \n[19] \"textfeature_text_copy_n_uq_hashtags\" \"textfeature_text_copy_n_mentions\"   \n[21] \"textfeature_text_copy_n_uq_mentions\" \"textfeature_text_copy_n_commas\"     \n[23] \"textfeature_text_copy_n_periods\"     \"textfeature_text_copy_n_exclaims\"   \n[25] \"textfeature_text_copy_n_extraspaces\" \"textfeature_text_copy_n_caps\"       \n[27] \"textfeature_text_copy_n_lowers\"      \"textfeature_text_copy_n_urls\"       \n[29] \"textfeature_text_copy_n_uq_urls\"     \"textfeature_text_copy_n_nonasciis\"  \n[31] \"textfeature_text_copy_n_puncts\"      \"textfeature_text_copy_politeness\"   \n[33] \"textfeature_text_copy_first_person\" \n```\n:::\n:::\n\n\n\n\n## Vorhersagen\n\nWir beziehen uns auf das Modell von @sec-klassifik-fit3.\n\n\n::: {.cell hash='hatespeech2_cache/html/read-fit3-fit3-final_3a47449f796328bae92fff96a16d7043'}\n\n```{.r .cell-code}\nfit3 <- read_rds(\"/Users/sebastiansaueruser/github-repos/datascience-text/objects/chap_classific_fit3.rds\")\n\nfit3_final_train <- read_rds(\"/Users/sebastiansaueruser/datasets/Twitter/hate-classific/fit3_final_train.rds\")\n```\n:::\n\n\n\n\n\nUnd nutzen dann die [predict](https://parsnip.tidymodels.org/reference/predict.model_fit.html)-Methode von `{tidymodels}`:\n\n\n::: {.cell hash='hatespeech2_cache/html/predict-fit3_d8791596d628c4bdc3a93ea45814a99f'}\n\n```{.r .cell-code}\ntic()\nd_predicted_values <- predict(fit3_final_train, d_predict2)\ntoc()\nbeep()\n```\n:::\n\n\n\n\nPuh, hier ist mein Rechner abgestürzt,\nals ich es mit ca. 2 Millionen Tweets versucht habe!\n\nBesser, wir probieren erstmal mit einem winzigen Teil der Daten,\nob unsere Funktion \"im Prinzip\" oder \"grundsätzlich\" funktioniert:\n\n\n\n\n::: {.cell hash='hatespeech2_cache/html/predict-fit3-tiny_c6312bfb3d59cf6332171d891113fe52'}\n\n```{.r .cell-code}\nd_predicted_values_tiny <- predict(fit3_final_train, head(d_predict2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError:\n! Can't convert `data$id` <integer> to match type of `id` <character>.\n```\n:::\n\n```{.r .cell-code}\nd_predicted_values_tiny\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'd_predicted_values_tiny' not found\n```\n:::\n:::\n\n\n\nFunktioniert! Gut! Also weiter.\n\n\n\nPasst!\n\n\n\n\n## Ergebnisse\n\n### Hass-Proxis pro Politiki insgesamt\n\n\n\n::: {.cell hash='hatespeech2_cache/html/res-summary1_1114359ad5d049bb5ad440fc33a33946'}\n\n```{.r .cell-code}\nres_summary1 <- \nd_predict2 %>% \n  group_by(dataset) %>% \n  summarise(emo_words_n_mean = mean(emo_words_n),\n            profane_words_count_mean = mean(profane_n),\n            wild_emojis_n_mean = mean(wild_emojis_n),\n            exclaims_n_mean = mean(textfeature_text_copy_n_exclaims))\n\n\nres_summary1_long <-\n  res_summary1 %>% \n    pivot_longer(-dataset, names_to = \"hate_proxy\", values_to = \"prop\")\n```\n:::\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-10_e99abd9f9d875c71e13334457b28a036'}\n\n```{.r .cell-code}\nres_summary1_long %>% \n  ggplot(aes(x = prop, y = hate_proxy)) +\n  geom_col() +\n  facet_wrap(~ dataset)\n```\n\n::: {.cell-output-display}\n![](hatespeech2_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n\n### Hass-Proxis pro Politiki im Zeitverlauf\n\n\n\n::: {.cell hash='hatespeech2_cache/html/res-summary2_daf832d4ab51da7463e3f70ffac5b40a'}\n\n```{.r .cell-code}\nres_summary2 <- \nd_predict2 %>%\n  select(created_at, profane_n, dataset, emo_words_n, wild_emojis_n, textfeature_text_copy_n_exclaims) %>% \n  mutate(month = ymd_hms(created_at) %>% round_date(unit = \"month\")) %>% \n  group_by(month, dataset) %>% \n  summarise(emo_words_n_mean = mean(emo_words_n),\n            profane_words_count_mean = mean(profane_n),\n            wild_emojis_n_mean = mean(wild_emojis_n),\n            exclaims_n_mean = mean(textfeature_text_copy_n_exclaims)) %>% \n  rowwise() %>% \n  mutate(hate_proxy = mean(c_across(emo_words_n_mean:exclaims_n_mean))) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nres_summary2 %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|month      |dataset             | emo_words_n_mean| profane_words_count_mean| wild_emojis_n_mean| exclaims_n_mean| hate_proxy|\n|:----------|:-------------------|----------------:|------------------------:|------------------:|---------------:|----------:|\n|2021-04-01 |Janine_Wissler_2021 |                0|                        0|                  0|               0|       0.00|\n|2021-05-01 |Janine_Wissler_2021 |                1|                        0|                  0|               0|       0.25|\n|2021-06-01 |Janine_Wissler_2021 |                1|                        0|                  0|               0|       0.25|\n|2021-09-01 |Janine_Wissler_2021 |                0|                        0|                  0|               0|       0.00|\n|2021-10-01 |Janine_Wissler_2021 |                0|                        0|                  0|               0|       0.00|\n|2021-11-01 |Janine_Wissler_2021 |                0|                        0|                  0|               0|       0.00|\n\n</div>\n:::\n:::\n\n\nLangifizieren fürs Plotten:\n\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-11_e05952af94cf481f892570f48c8935be'}\n\n```{.r .cell-code}\nres_summary2_long <- \n  res_summary2 %>% \n  pivot_longer(emo_words_n_mean:hate_proxy)\n\nres_summary2_long %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|month      |dataset             |name                     | value|\n|:----------|:-------------------|:------------------------|-----:|\n|2021-04-01 |Janine_Wissler_2021 |emo_words_n_mean         |     0|\n|2021-04-01 |Janine_Wissler_2021 |profane_words_count_mean |     0|\n|2021-04-01 |Janine_Wissler_2021 |wild_emojis_n_mean       |     0|\n|2021-04-01 |Janine_Wissler_2021 |exclaims_n_mean          |     0|\n|2021-04-01 |Janine_Wissler_2021 |hate_proxy               |     0|\n|2021-05-01 |Janine_Wissler_2021 |emo_words_n_mean         |     1|\n\n</div>\n:::\n:::\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-12_a4544cb13dce9ec32d4fcf586a860263'}\n\n```{.r .cell-code}\nres_summary2_long %>% \n  count(month)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|month      |  n|\n|:----------|--:|\n|2021-04-01 |  5|\n|2021-05-01 |  5|\n|2021-06-01 |  5|\n|2021-09-01 |  5|\n|2021-10-01 |  5|\n|2021-11-01 |  5|\n|2021-12-01 |  5|\n|2022-06-01 |  5|\n|2022-09-01 |  5|\n|2022-11-01 |  5|\n|NA         |  5|\n\n</div>\n:::\n:::\n\n::: {.cell hash='hatespeech2_cache/html/unnamed-chunk-13_b98322adb04b5ce889a3c9c73ca93b9c'}\n\n```{.r .cell-code}\nres_summary2_long %>% \n  ggplot() +\n  aes(x = month, y = value) +\n  facet_grid(dataset  ~ name) +\n  geom_point() +\n  geom_line(group=1, alpha = .7)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 5 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 5 rows containing missing values (`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](hatespeech2_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}