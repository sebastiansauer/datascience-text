{"title":"Twitter Mining","markdown":{"headingText":"Twitter Mining","containsRefs":false,"markdown":"\n\n\n![Text als Datenbasis prädiktiver Modelle](img/text-mining-1476780_640.png){width=10%}\n\nBild von <a href=\"https://pixabay.com/de/users/mcmurryjulie-2375405/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1476780\">mcmurryjulie</a> auf <a href=\"https://pixabay.com/de//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1476780\">Pixabay</a>\n\n\n\n\n## Vorab\n\n\n### Lernziele\n\n\n- Twitterdaten via API von Twitter auslesen\n\n\n\n### Vorbereitung\n\n- Lesen Sie in @smltar Kap. 1.\n- Legen Sie sich ein Konto bei [Github](https://github.com/) an.\n- Legen Sie sich ein Konto bei [Twitter](twitter.com) an.\n- Lesen Sie [diesen Artikel zur Anmeldung bei der Twitter API](https://docs.ropensci.org/rtweet/articles/auth.html)^[Sie können [hier](https://www.howtogeek.com/343877/what-is-an-api/) nachlesen, was eine API ist.]\n\n\n\n\n### Benötigte R-Pakete\n\n\n\n```{r}\n#| message: false\nlibrary(tidyverse)\nlibrary(rtweet)\nlibrary(tweetbotornot)\n```\n\n![R-Paket {rtweet}](https://docs.ropensci.org/rtweet/logo.png){width=10%}\n\n\nEinen Überblick über die Funktionen des Pakets (function reference) findet sich [hier](https://docs.ropensci.org/rtweet/reference/index.html).\n\n\n\n## Anmelden bei Twitter\n\n\n### Welche Accounts interessieren uns?\n\n\nHier ist eine (subjektive) Auswahl von deutschen Politikern^[Stand November 2022],\ndie einen Startpunkt gibt zur Analyse von Art und Ausmaß von Hate Speech gerichtet an deutsche Politiker:innen.\n\n```{r politicians-df-load}\n#| message: false\nd_path <- \"data/twitter-german-politicians.csv\"\n\nd <- read_csv(d_path)\nd\n```\n\n\n\n### Twitter App erstellen\n\n[Tutorial](https://cran.r-project.org/web/packages/rtweet/vignettes/auth.html)\n\n\n### Intro\n\nDie Seite von [rtweet](https://docs.ropensci.org/rtweet/) gibt eine gute Starthilfe in die Benutzung des Pakets.\n\n\n### Zugangsdaten\n\n\nZugangsdaten sollte man geschützt speichern, also z.B. *nicht* in einem geteilten Ordner.\n\n\n```{r source-credentials-twitter}\nsource(\"/Users/sebastiansaueruser/credentials/hate-speech-analysis-v01-twitter.R\")\n```\n\n\nAnmelden:\n\n```{r oauth-twitter}\n#| eval: false\nauth <- rtweet_bot(api_key = api_key,\n                   api_secret = api_secret,\n                   access_token = access_token,\n                   access_secret = access_secret)\n```\n\n\nAlternativ kann man sich auch als `App` anmelden,\ndamit kann man z.B. nicht posten, aber dafür mehr herunterladen.\n\n\n```{r}\n#| eval: false\nauth <- rtweet_app(bearer_token = Bearer_Token)\n```\n\n\n\n## Tweets einlesen\n\n\nZu beachten ist, dass es Limits gibt, wie viele Informationen (pro Zeiteinheit) man über die Twitter-API auslesen darf.\nInformationen dazu findet man z.B. [hier](https://developer.twitter.com/en/docs/twitter-api/rate-limits) oder auch mit `rate_limit()`.\n\n\n\n\n\nEin gängiges Limit der Twitter-API sind 900 Anfragen (z.B. Tweets auslesen) pro 15 Minuten.\n\n### Timeline einlesen einzelner Accounts\n\nMal ein paar Tweets zur Probe:\n\n```{r}\n#| eval: false\nsesa_test <- get_timeline(user = \"sauer_sebastian\", n = 3) %>% \n  select(full_text)\n```\n\n\n```{r}\n#| echo: false\nsesa_test <- readRDS(file = \"tweets/sesa-test.rds\")\n\nwriteLines(sesa_test$full_text)\n```\n\n\n\n```{r get-timeline1}\n#| eval: false\ntweets <- get_timeline(user = d$screenname)\nsaveRDS(tweets, file = \"tweets/tweets01.rds\")\n```\n\n\n[Michael Kearney](https://rtweet-workshop.mikewk.com/#25) rät uns:\n\n>   PRO TIP #4: (for developer accounts only) Use `bearer_token()` to increase rate limit to 45,000 per fifteen minutes.\n\n### Retweets einlesen\n\n\n\n```{r get-retweets1}\n#| eval: false\n\ntweets01_retweets <- \n  tweets$id_str %>% \n  head(3) %>% \n  map_dfr( ~ get_retweets(status_id = .x, retryonratelimit = TRUE))\n```\n\n\n\nDa die meisten Retweets aber nix sagen, sondern nur auf das einen Tweet wiederholen, ist das Sammeln der Retweets ziemlich langweilig.\n\n\nMöchte man `retry on rate limit` im Standard auf `TRUE` setzen, \nso kann man das über die Optionen von R tun.\n\n```{r}\noptions(rtweet.retryonratelimit = TRUE)\n```\n\n\n\n### EPINetz Twitter Politicians 2021\n\n\n@konig_epinetz_2022 [Volltext hier](https://link.springer.com/article/10.1007/s11615-022-00405-7) haben einen Datensatz mit knapp 2500 Twitter Accounts deutscher Politiker zusammengestellt, zum Stand 2021.\n\n\nDer Datensatz kann über [Gesis](https://search.gesis.org/research_data/SDN-10.7802-2415?doi=10.7802/2415) bezogen werden.\n\nAuf der gleichen Seite findet sich auch eine [Dokumentation des Vorgehens](https://access.gesis.org/sharing/2415/3675).\n\nNachdem wir den Datensatz heruntergeladen haben, können wir ihn einlesen:\n\n```{r read-epinetz}\npoliticians_path <- \"data/EPINetz_TwitterPoliticians_2021.RDs\"\npoliticians_twitter <- read_rds(politicians_path)\n\nhead(politicians_twitter)\n```\n\nDann lesen wir die Timelines (die Tweets) dieser Konten aus;\nin diesem Beispiel nur 10 Tweets pro Account:\n\n\n```{r get-timeline2}\n#| eval: false\nepi_tweets <- get_timeline(user = head(politicians_twitter$twitter_name), n = 10)\nhead(epi_tweets)\n```\n\n\nNatürlich könnte man auch mehr als 10 Tweets pro Konto einsammeln, braucht nur seine Zeit.\n\n### Followers suchen\n\n\n\n\n```{r save-followers1}\n#| eval: false\nfollowers01 <-\n  d$screenname %>% \n map_dfr( ~ get_followers(user = .x, retryonratelimit = TRUE))\n\n```\n\n\nDa es dauern kann, Daten auszulesen (wir dürfen pro 15 Min. nur eine begrenzte Zahl an Information abrufen), kann es Sinn machen, die Daten lokal zu speichern.\n\n\n\n```{r save-flllowers01}\n#| eval: false\nsaveRDS(followers01, file = \"tweets/followers01.rds\")\n```\n\n\nUnd ggf. wieder importieren:\n\n```{r read-flllowers0}\nfollowers01 <- read_rds(file = \"tweets/followers01.rds\")\n```\n\n\nWie viele unique Followers haben wir identifiziert?\n\n```{r}\nfollowers02 <- \n  followers01 %>% \n  distinct(from_id)\n```\n\n\nDie Screennames wären noch nützlich:\n\n\n```{r}\n#| eval: false\nlookup_users(users = \"1690868335\")\n```\n\n\nDie Anzahl der Users, die man nachschauen kann, ist begrenzt auf 180 pro 15 Minuten.\n\n```{r}\n#| eval: false\nfollowers03 <-\n  followers02 %>% \n  mutate(screenname = \n           list(lookup_users(users = from_id, retryonratelimit = TRUE,verbose = TRUE)))\n```\n\n\n\n\nEntsprechend kann man wieder einlesen:\n\n\n\n\nDamit haben wir eine Liste an Followers, deren Tweets wir einlesen und analysieren können,\nz.B. nach Hate Speech.\n\nIm Gegensatz zu Followers heißen bei Twitter die Accounts, denen ei Nutzi folgt \"Friends\".\n\n\nLesen wir mal die Followers von `karl_lauterbach` ein:\n\n\n```{r}\n#| eval: false\nkarl_followers <- get_followers(user = \"karl_lauterbach\", verbose = TRUE)\n```\n\n\nUm nicht jedes Mal aufs Neue die Daten herunterzuladen, \nbietet es sich an, die Daten lokal zu speichern:\n\n\n```{r}\n#| eval: false\nwrite_rds(karl_followers, file = \"tweets/karl_followers.rds\",\n          compress = \"gz\")\n```\n\nEntsprechend kann man die Daten dann auch wieder einlesen:\n\n\n```{r read-karl-followers}\nkarl_followers <- read_rds(file = \"tweets/karl_followers.rds\")\n```\n\n\n\n\n### Follower Tweets einlesen\n\n\n```{r get-timeline3}\n#| eval: false\nfollowers_tweets <- get_timeline(user = head(followers01$from_id), n = 10)\n```\n\n\n\n\n\n\n\n\n## Tweets verarbeiten\n\n\n### Grundlegende Verarbeitung\n\nSind die Tweets eingelesen, kann man z.B. eine Sentimentanalyse, s. @sec-sentimentanalyse, durchführen, oder schlicht vergleichen, welche Personen welche Wörter häufig verwenden, s. @sec-woerterzaehlen.\n\n\n\n### Bot or not?\n\nEine interessante Methode, Tweets zu verarbeiten, bietet das R-Paket `tweetbotornot` von [M. Kearney](https://github.com/mkearney/tweetbotornot).\n\n\nAus der `Readme`: \n\n\n>   Due to Twitter’s REST API rate limits, users are limited to only 180 estimates per every 15 minutes. To maximize the number of estimates per 15 minutes (at the cost of being less accurate), use the fast = TRUE argument. This method uses only users-level data, which increases the maximum number of estimates per 15 minutes to 90,000! Due to losses in accuracy, this method should be used with caution!\n\n\n\n\n\n```{r}\n#| eval: FALSE\nusers <- c(\"sauer_sebastian\")\nbot01 <-\n  tweetbotornot(users)\n```\n\n\n\n:::callout-important\nIch habe ein Fehlermeldung bekommen bei `tweetbotornot`.\nDa könnte ein technisches Problem in der Funktion vorliegen.\n:::\n\n\n\n\n\n\n## Cron Jobs\n\n\n\n### Was ist ein Cron Job?\n\n[Cron](https://en.wikipedia.org/wiki/Cron) ist ein Programm auf Unix-artigen Betriebssystemen, das Skripte zu eingestellten Zeiten (wiederholt) ausführt, das sind dann \"Cron Jobs\".\nAuf Windows gibt es aber analoge Funktionen.\nCron Jobs sind praktisch, da man nicht jedes Mal selber z.B. Tweets, die heute zu einem Thema getweetet wurden, herunterladen muss.\nDas wird dann vom Cron Job übernommen.\n\nIn R gibt es eine API zum Programm Cron mit dem Paket `{cronR}`, s. [Anleitung hier](https://github.com/bnosac/cronR).\n\nDas analoge R-Paket für Windows heißt [`{taskscheduleR}`](https://github.com/bnosac/taskscheduleR).\n\n\n\n### Beispiel für einen Cron Job\n\n\n```{r}\n#| eval: false\nlibrary(cronR)\n\nscrape_script <- cron_rscript(\"scrape_tweets.R\")\n\n# Cron Job hinzufügen:\ncron_add(command = scrape_script, \n         frequency = 'daily', \n         at = \"10AM\",\n         id = 'Hate Speech')  # Name des Cron Jobs\n\ncron_clear(ask = FALSE)  # Alle Cron Jobs löschen\ncron_ls()  # Liste aller Cron Jobs\n```\n\n\nIm obigen Beispiel wird das R-Skript `scrape_tweets.R` täglich um 10h ausgeführt.\n\n\n\n\nDer Inhalt von `scrape_tweets.R` könnte dann, in Grundzügen, so aussehen:\n\n\n```{r}\n#| eval: false\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(rtweet)\nfollowers_lauterbach <-\n  followers01 %>% \n  filter(to_id == \"Karl_Lauterbach\")\n\nfollowers_lauterbach_tweets <- \n  get_timeline(user = followers_lauterbach$from_id[1:10], n = 10, retryonratelimit = TRUE, verbose = FALSE)\n\n\npath_output <- \"/Users/sebastiansaueruser/Google Drive/RRRing/Scrape-Tweets/tweets/\"\n\nwrite_csv(x = followers_lauterbach_tweets,\n          file = paste0(path_output, \"followers_lauterbach_tweets.csv\"),\n          append = TRUE)\n\n```\n\n\nWir schreiben nicht jedes Mal (jeden Tag) eine neue CSV-Datei, sondern wir hängen hier die neu ausgelesenen Daten an die Datei an.\n\nLeider ist es mit `rtweet` nicht möglich, ein Datum anzugeben, ab dem man Tweets auslesen möchte^[Mit dem R-Paket `twitteR`, das mittlerweile zugunsten von `rtweet` aufgegeben wurde, war das möglich. Allerdings zeigt ein [Blick in die Dokumentation der Twitter-API](https://developer.twitter.com/en/docs/twitter-api/v1/tweets/timelines/api-reference/get-statuses-home_timeline), das Datumsangaben offenbar gar nicht unterstützt werden.]\n\n\n## Datenbank an Tweets aufbauen\n\n\n### Stamm an bisherigen Tweets\n\nIn diesem Abschnitt kümmern wir uns in größerem Detail um das Aufbauen einer Tweets-Datenbank.\n\n\nDiese Pakete benötigen wir:\n\n```{r}\nlibrary(rtweet)\nlibrary(tidyverse)\nlibrary(rio)  # R Data import/export\n```\n\n\nDann melden wir uns an:\n\n```{r}\nsource(\"/Users/sebastiansaueruser/credentials/hate-speech-analysis-v01-twitter.R\")\nauth <- rtweet_app(bearer_token = Bearer_Token)\n```\n\n\nDann brauchen wir eine Liste an Twitterkonten,\ndie uns interessieren.\nIm Kontext von Hate Speech soll uns hier interessieren,\nwelche Tweets *an* deutsche Spitzenpolitikis^[zur Zeit, als diese Zeilen geschrieben wurden] gesendet werden.\nWir suchen also nach Tweets mit dem Text `@karl_lauterbach`,\num ein Beispiel für einen Spitzenpolitiker zu nennen, der vermutlich von Hate Speech in höherem Maße betroffen ist.\n\n\n```{r}\npoliticians_twitter_path <- \"/Users/sebastiansaueruser/github-repos/datascience-text/data/twitter-german-politicians.csv\"\n\npoliticians_twitter <- rio::import(file = politicians_twitter_path)\n```\n\n\n\nIn der Liste befinden sich 13 Politiker.\nEs macht die Sache vielleicht einfacher,\nwenn wir die Rate nicht überziehen.\nBleiben wir daher bei 1000 Tweets pro Politiki:\n\n\n```{r}\nn_tweets_per_politician <- 1e3\n```\n\n\nDie R-Syntax, die die Arbeit leistet,\nist in Funktionen ausgelagert,\nder Übersichtlichkeit halber.\n```{r}\nsource(\"funs/filter_recent_tweets.R\")\nsource(\"funs/download_recent_tweets.R\")\nsource(\"funs/add_tweets_to_tweet_db.R\")\n```\n\n\n\n```{r}\n#| echo: false\ntweets_older <- read_rds(file = \"~/datasets/Twitter/tweets-politicians-2022-11-11.rds\")\n```\n\nJetzt laden wir einfach die aktuellsten 1000 Tweets\npro Konto herunter,\ndaher brauchen wir keine Tweet-ID angeben,\ndie ein Mindest- oder Maximum-Datum (bzw. ID) für einen \nTweet angibt:\n\n```{r}\n#| eval: false\ntweets_older <-\n  download_recent_tweets(screenname = politicians_twitter$screenname,\n                         max_or_since_id_str = NULL,\n                         n = n_tweets_per_politician,\n                         strip_columns = TRUE,\n                         reverse = TRUE)\n```\n\n\nWie weit in die Vergangenheit reicht unsere Tweet-Sammlung?\n\n```{r}\noldest_tweets <- filter_recent_tweets(tweets_older, max_or_min_id_str = is_min_id_str)\noldest_tweets\n```\n\n\nWas sind die neuesten Tweets, die wir habven?\n\n```{r}\nmost_recent_tweets <- filter_recent_tweets(oldest_tweets)\nmost_recent_tweets\n```\n\n\nJetzt laden wir die *neueren* Tweets herunter,\nalso mit einer ID *größer* als die größte in unserer Sammlung:\n\n```{r}\n#| echo: false\ntweets_new <- \n  read_rds(file = \"~/datasets/Twitter/tweets-politicians-2022-11-11a.rds\")\n```\n\n\n```{r}\n#| eval: false\ntweets_new <- \n  download_recent_tweets(screenname = most_recent_tweets$screenname,\n                         max_or_since_id_str = most_recent_tweets$id_str)\n\ntweets_new %>% \n  select(screenname, created_at, id_str) %>% \n  head()\n```\n\n\n\nJetzt - und jedes Mal, wenn wir Tweets herunterladen - \nfügen wir diese einer Datenbank (oder zumindest einer \"Gesamt-Tabelle\") hinzu:\n\n```{r}\ntweets_db <- add_tweets_to_tweets_db(tweets_new, tweets_older)\n\nnrow(tweets_db)\n```\n\n\nSchließlich sollten wir nicht vergessen\ndiese in einer Datei zu speichern:\n\n```{r}\n#| eval: false\nwrite_rds(tweets_db, file = \"~/datasets/Twitter/tweets-db-2022-11-11.rds\")\n```\n\n\n\n... ... So, einige Zeit ist vergangen.\nLaden wir noch ältere Tweets herunter und fügen Sie unserer Datenbank hinzu:\n\n```{r}\n#| eval: false\ntweets_older2 <-\n  download_recent_tweets(screenname = politicians_twitter$screenname,\n                         max_or_since_id_str = oldest_tweets$id_str,\n                         n = 1e3,\n                         strip_columns = TRUE,\n                         reverse = TRUE)\n```\n\n\n```{r}\n#| echo: false\ntweets_older2 <- read_rds(file = \"~/datasets/Twitter/tweets-politicians-2022-11-11b.rds\")\n```\n\n\n\n```{r}\ntweets_db <- add_tweets_to_tweets_db(tweets_new, tweets_older2)\n\nnrow(tweets_db)\n```\n\n\nUnd wieder speichern wir die vergrößerte Datenbasis auf der Festplatte:\n\n```{r}\nwrite_rds(tweets_db, file = \"~/datasets/Twitter/hate-speech-twitter.rds\")\n```\n\nLeider ist die Datenbasis nicht mehr deutlich gewachsen.\nEine plausible Ursache ist, dass Twitter den Zugriff auf alte Tweets einschränkt.\n\n\n\n### Neue Tweets per Cron Job\n\n\nWie oben schon ausprobiert,\nlegen wir uns einen Cron Job an.\n\n```{r}\n#| eval: false\nlibrary(cronR)\n\nscrape_script <- cron_rscript(\"/Users/sebastiansaueruser/github-repos/datascience-text/funs/get_tweets_politicians.R\")\n\n# Cron Job hinzufügen:\ncron_add(command = scrape_script, \n         frequency = 'daily', \n         at = \"10AM\",\n         id = 'Hate Speech')  # Name des Cron Jobs\n\n```\n\n\nDas Skript `get_tweets_politicians.R` birgt die Schritte,\ndie wir in diesem Abschnitt ausprobiert haben.\nKurz gesagt sucht es nach neuen Tweets, die \nalso noch nicht in Ihrer \"Datenbank\" vorhanden sind,\nund lädt diese herunter.\nDabei werden maximal 1000 Tweets pro Konto (derer sind es 13)\nheruntergeladen.\n\n:::callout-note\nSchauen Sie sich die Funktionen im Ordner `/funs` einmal in Ruhe an.\n[Hier](https://github.com/sebastiansauer/datascience-text/tree/main/funs) geht es zu dem Ordner im Github-Repo.\nEs ist alles keine Zauberei,\naber im Detail gibt es immer wieder Schwierigkeiten.\nAm meisten lernt man,\nwenn man selber Hand anlegt.\n:::\n\n\n\nMöchte man den Cron Job wieder löschen, so kann man das so tun:\n\n\n```{r}\n#| eval: false\ncron_clear(ask = FALSE)  # Alle Cron Jobs löschen\ncron_ls()  # Liste aller Cron Jobs\n```\n\n\n\n\n\n## Aufgaben\n\n1. Überlegen Sie, wie Sie das Ausmaß an Hate Speech, dem deutsche Politikerinnen und Politiker konfrontiert sind, messen können.\n2. Argumentieren Sie die Vorteile und Nachteile Ihres Ansatzes. Außerdem, auf welches Ergebnis dieser Analyse sie gespannt sind bzw. wären.\n3. Überlegen Sie Korrelate, oder besser noch: (mögliche) Ursachen, des Hasses in den Tweets, gerichtet auf Polikter:innen. Sie können auch Gruppen von Ursachen bilden, etwas personengebundene Variablen der Politiker:innen (z.B. Alter? Geschlecht? Migrationshintergrund?).\n1. Erstellen Sie sich eine Liste an Personen, deren Tweets sich lohnen (könnten), auf Hate Speech hin analysiert zu werden. Laden Sie deren Tweets (ggf. in Auszügen) herunter.\n6. Das Skript zu `scrape_tweets.R` könnte man noch verbessern, in dem man jeden Tag nur die neuesten Tweets herunterlädt. Dazu kann man bei [get_timeline()](https://docs.ropensci.org/rtweet/reference/get_timeline.html) mit dem Argument `since_id` eine Untergrenze der ID festlegen, so dass nur neuere Tweets (d.h. mit größerem Wert bei ID) ausgelesen werden. Ändern Sie das Skript entsprechend, so dass nur neuerer Tweets gelesen werden.\n7. Erarbeiten Sie die Folien zu diesem [rtweet-Workshop](https://rtweet-workshop.mikewk.com/#1). Eine Menge guter Tipps!\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"twittermining.html"},"language":{},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.1.168","bibliography":["references.bib"],"editor":"source","knitr":{"opts_chunk":{"fig-align":"center","out-width":"70%"}},"theme":"cerulean"},"extensions":{"book":{"multiFile":true}}}}}